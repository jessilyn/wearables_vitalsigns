
# Framework Paper Figures
# built from 20170905_thirtyk.R

#### OUTPUT: Figures for paper

#### LIBRARY DEPENDENCIES:
library(ggplot2)
library(data.table)
library(psych)
library(nlme)
library(MuMIn)
library(Rmisc)
library(gridExtra)
library(grid)
library(dplyr)
library(MASS)
library("ggthemes")
library(reshape2)
library(randomForest)
library("glmnet")

if(!dir.exists("plots")) dir.create("plots")

# FUNCTIONS
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

# Path to the directory with data
dir = "../SECURE_data/"

###################
#### READ DATA ####
###################

#iPOP wearables/clinical combined data
# wear <- read.csv(paste0(dir, "Basis2016_Cleaned_NotNorm0824_WeekPrior.csv"),
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for Lukasz script
# do not use:  wear <- read.csv("/Users/jessilyn/Documents/Career_Development/Mentoring/RyanRunge/20170803_FINAL_LASSOS/Basis2016_Norm0824_WeekPrior.csv",
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for other figures, may need to resurrect this one
timespans <-c("AllData",
              "MonthPrior",
              "2WeekPrior",
              "WeekPrior",
              "5DayPrior",
              "3DayPrior",
              "DayPrior" )

wear <- read.csv(paste0("/Users/jessilyn/Desktop/framework_paper/Figure2/20171103_Output_Tables_from_All_Lassos/Basis_Timespan_Subset_Tables_for_Lassos/", 
                "Basis2016_Clean_Norm_", timespans[7], "_20180504.csv"),
                 header=TRUE,sep=',',stringsAsFactors=FALSE)

# iPOP vitals (called vitals in Lukasz script)
setwd("/Users/jessilyn/Desktop/framework_paper/weartals")
iPOPvitals <- read.csv(paste0(dir, "vitals.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP Labs (called labs in Lukasz script)
iPOPlabs <- read.csv(
  paste0(dir, "lab_results_20170717.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

# 30k vitals
vitals <- fread(paste0(dir, "all_vitals.csv"),
                header=TRUE,sep=',',stringsAsFactors=FALSE)
vitals <- data.frame(vitals)
# 30k labs
labs <- fread(paste0(dir, "all_labs.csv"),
              header=TRUE,sep=',',stringsAsFactors=FALSE)
# 30K labs/vitals combined file <- generated by 20170908_thirtyk.R or 20180412_thirtyk.R (where new vitals like BP and respiration are added in)
# corDf <- read.csv(paste0(dir, "20170905_Cleaned_joined_30k_labs_vitals.csv"),
#                    header=TRUE,sep=',',stringsAsFactors=FALSE)
corDf <- read.csv(paste0(dir, "20180412_Cleaned_joined_30k_labs_ALLvitals.csv"),
                   header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP demographics
iPOPdemographics <- read.csv(paste0(dir, "SECURE_ClinWearDemo_SamplePop.csv"),
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

#thirtyK demographics
thirtyKdemog <- read.csv(paste0(dir, "SECURE_20180412_thirtyKDemog.csv"),
         header=TRUE,sep=',',stringsAsFactors=FALSE)

# names of top clinical tests that will be used for the downstream analyses
top.names<-top.names<-c("LYM", "NEUT", "LYMAB", "NEUTAB", "IGM", "HSCRP", "ALKP", "ALT", "HDL", "MCV", "TBIL", "CHOLHDL", "GLOB", "AG", "CO2", "CA", "LDLHDL", "BUN", "NHDL", "NA.", "UALB", "MONOAB", "CHOL", "MONO", "RDW", "HCT", "TP", "TGL", "EOS", "LDL", "GLU", "AST", "PLT", "K", "EOSAB", "BASOAB", "MCH", "ALB", "HGB", "A1C", "CL", "RBC", "BASO", "MCHC") # names of lab tests from the 30k simple bivariate models

###################
### CLEAN DATA ####
###################

### clean iPOP Vitals ###
names(iPOPvitals)[which(names(iPOPvitals)=="HIMCID")] <- "iPOP_ID"
names(iPOPvitals)[which(names(iPOPvitals)=="RECORDED_TIME")] <- "Clin_Result_Date"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Pulse.")] <- "Pulse"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Temp.")] <- "Temp"
names(iPOPvitals)[which(names(iPOPvitals)=="X.BP.")] <- "BP"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Bmi.")] <- "BMI"

for (i in 1:length(iPOPvitals$BP)){
  iPOPvitals$systolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][1]
  iPOPvitals$diastolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][2]
}

#Reformat dates
iPOPvitals$Clin_Result_Date <- format(
  as.Date(iPOPvitals$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

#Make correlation variables numeric
iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")] <- apply(
  iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")], 2,
  function(x) as.numeric(as.character(x)))

#### CLEAN iPOP LABS DATA ####

#Rename columns
names(iPOPlabs)[which(names(iPOPlabs)=="HIMC_ID")] <- "iPOP_ID"
names(iPOPlabs)[which(names(iPOPlabs)=="RESULT_TIME")] <- "Clin_Result_Date"

#Reformat dates
iPOPlabs$Clin_Result_Date <- format(
  as.Date(iPOPlabs$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

# allClin <- c("A1C","AG","ALB","ALCRU","ALKP","ALT","AST","BASO",
#              "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
#              "CR","EGFR","EOS","EOSAB","ESR","GLOB","GLU","HCT","HDL",
#              "HGB","HSCRP","IGM","K","LDL","LDLHDL","LYM","LYMAB",
#              "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
#              "NEUTAB","NHDL","PLT", "RBC","RDW","TBIL","TGL","TP","UALB","UALBCR","WBC") 

allClin <- c("ALKP", "LYM", "HSCRP", "ALT", "NEUT", "TBIL", "IGM", "TGL", "MCV", "MCH", "CO2", "LYMAB", "NEUTAB", "UALB", "CHOL", "MONOAB", "ALB", "NA.", "HDL", "PLT", "AG", "HGB", "EOS", "CL", "BUN", "GLOB", "CA", "CHOLHDL", "HCT", "BASOAB", "A1C", "GLU", "LDLHDL", "TP", "EOSAB", "K", "NHDL", "RBC", "MONO", "AST", "MCHC", "RDW", "BASO", "LDL")

for(i in 1:length(allClin)){ #this removes non-numeric characters
  cache <- iPOPlabs[,c(allClin[i])]
  cache <- gsub("[^0-9.]","",cache) #this keeps decimals
  iPOPlabs[,c(allClin[i])] <- cache
}
#Make correlation variables numeric
iPOPlabs[,c(allClin)] <- apply(
  iPOPlabs[,c(allClin)], 2,
  function(x) as.numeric(as.character(x)))

#subset by allClin
iPOPlabs <- iPOPlabs[names(iPOPlabs) %in% c("iPOP_ID","Clin_Result_Date",allClin)]

#Merge data
iPOPcorDf <- merge(iPOPlabs,
                   iPOPvitals[,c("iPOP_ID","Clin_Result_Date",
                                 "Pulse","Temp","BMI","systolic","diastolic")],
                   by=c("iPOP_ID","Clin_Result_Date"))

### clean iPOPcorDf ###
iPOPcorDf[, -c(1,2)] <- apply(iPOPcorDf[, -c(1,2)], 2, remove_outliers)

### clean corDf ### 
corDf[, -c(1,2)] <- apply(corDf[, -c(1,2)], 2, remove_outliers) 

### clean wear ### messes up code for Fig 2C so edited it out, but might be necessary for the CCA in Fig 2E
# wear2<-wear
# wear[,-c(1:6)] <- sapply(wear[,-c(1:6)], as.numeric)
# wear[,-c(1:6)] <- apply(wear[,-c(1:6)], 2, remove_outliers) 

## merge iPOP and demographics
iPOPcorDf.demo <- merge(iPOPcorDf, iPOPdemographics[1:4], by="iPOP_ID")

####################
#### Figure 1  #####
####################
iPOPdaysMonitored <- read.csv("/Users/jessilyn/Desktop/framework_paper/Figure1/Slide 2/slide2_C_participant_data_summary.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

###############################
# Fig 1B, left, middle, right #
###############################
hist(iPOPdaysMonitored$Days_monitored_by_clinic, col="grey", breaks=20,
     xlab = "Time Monitored by Clinic (Days)", main = NULL, font.lab=2,lwd=2,font=2)
hist(iPOPdaysMonitored$Days_monitored_by_basis, col="grey", breaks=20,
     xlab = "Time Monitored by Watch (Days)", main = NULL, font.lab=2,lwd=2,font=2)
hist(iPOPdaysMonitored$Total_NumOfClinMeasures, col="grey", breaks=10,
     xlab = "Number of Clinic Visits / Person", main = NULL, font.lab=2,lwd=2,font=2)
mean(iPOPdaysMonitored$Total_NumOfClinMeasures)
mean(iPOPdaysMonitored$Days_monitored_by_clinic)

###############
# Fig 1C, top #
###############

hist(iPOPvitals$Pulse, col="darkred", breaks=50,
     xlab = "cHR", xlim=c(50,200),
     main = NULL, font.lab=2,lwd=2,font=2)
length(iPOPvitals$Pulse[!is.na(iPOPvitals$Pulse)]) # number of cHR measurements in iPOP cohort

hist(iPOPvitals$Temp, col="darkgrey", breaks=50,
     xlab = "cTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)
length(iPOPvitals$Temp[!is.na(iPOPvitals$Temp)]) # number of cTemp measurements in iPOP cohort

################################################
#  Figure 1C Bottom - see Ryans_Figure1_Code.R #
################################################
dfFigOneC <- fread(paste0("/Users/jessilyn/Desktop/framework_paper/Figure1/Fig1C/Ryans_input_files/BasisData_20161111_PostSummerAddOns_Cleaned_NotNormalized_20170928.csv"),
            header=TRUE,sep=",",stringsAsFactors = FALSE)
hist(dfFigOneC$Heart_Rate, col="darkred", breaks=100,
     xlab = "wHR",
     main = NULL, font.lab=2,lwd=2,font=2)

hist(dfFigOneC$Skin_Temperature_F, col="darkgrey", breaks=100,
     xlab = "wTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)

#characterize the iPOP data set
length(na.omit(iPOPvitals$Temp)) + length(na.omit(iPOPvitals$Pulse)) # total number of clinical vital signs measured
describe(iPOPlabs[names(iPOPlabs) %in% allClin]) # summary of clinical labs data
length(unique(wear$iPOP_ID)) # num people in iPOP wearables dataset

##########################################
#  Figure 1D  - see Ryans_Figure1_Code.R #
##########################################




#############################
#    Suppl. Table 1A and B  #
#############################

# make table for vitals (Suppl. Table 1A)
#describe(iPOPvitals)

# make table for labs
#describe(iPOPlabs)


###############
#  Figure 2C  #
###############

# creates ranked list of clinical laboratory tests by the %var explained in simple LM; LOO cross validation at the subject level 

source("ggplot-theme.R") # just to make things look nice
#top.names<-c("MONOAB", "HGB", "HCT", "MCHC") # for testing model on small subset

####
# CODE FOR SIMPLE LM
#
sum.vectors.in.list <- function(x) {
  c(sum(na.omit(x)))
}

rsq.all = c()
pct.var.all = c()
vitals.variables <- c("Pulse", "Temp", "AgeIn2016", "Gender", "Ethn") # "BMI", "systolic", "diastolic", 
iPOPcorDf.demo <- merge(iPOPcorDf, iPOPdemographics[1:4], by="iPOP_ID")
patients = unique(iPOPcorDf$iPOP_ID)

val.true <- rep(list(NA),length(top.names)) # list of vectors to store true values; each vector is for 1 clinical lab
val.pred <- rep(list(NA),length(top.names)) # list of vectors to store trained model predicted values; each vector is for 1 clinical lab
val.null.pred <- rep(list(NA),length(top.names)) # list of vectors to store null model predicted values; each vector is for 1 clinical lab
# p.value<-list()  # TODO: decide if this is a relevant parameter to collect - I think not...?
num.true <- rep(list(NA),length(top.names)) # number of observations per individual per clinic test

for (k in 1:length(patients)){
  train <- patients[patients != patients[k]]
  test <- patients[patients == patients[k]]
  cat("Patient",patients[k],"\n") # LOO
  dat.train<-iPOPcorDf.demo[ iPOPcorDf.demo$iPOP_ID %in% train, ] # subset input data by training set
  dat.test<-iPOPcorDf.demo[ iPOPcorDf.demo$iPOP_ID %in% test, ] # subset input data by testing set
  
  for (l in 1:length(top.names)){
    cat("Test",top.names[l],"\n")
    # create training set
    x.train<-dat.train[,colnames(dat.train) %in% c(top.names[l], vitals.variables)] # subset input data by lab: only take current lab test of interest
    x.train<- na.omit(x.train) # skip nas and nans ## TODO: the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
    predictors <- as.data.frame(x.train[,colnames(x.train) %in% c(vitals.variables)]) # later add in demographics
    outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
    # create test set
    x.test<-dat.test[,colnames(dat.test) %in% c(top.names[l], vitals.variables)] # subset input data by lab: only take current lab test of interest
    x.test<- na.omit(x.test) # skip nas and nans ## TODO: SEE ABOVE na.omit FOR ISSUE WITH THIS
    val.true[[l]] = c(val.true[[l]], x.test[,top.names[l]]) # true values of left out person
    num.true[[l]]<-c(num.true[[l]],length(x.test[,top.names[l]])) # number of test observations for left out person
    fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(vitals.variables,collapse=" + "))
    fml.null = paste(top.names[l]," ~ 1")
    bivar.lm.model = lm(as.formula(fml), data = x.train) # build the model
    val.pred[[l]] = c(val.pred[[l]], predict(bivar.lm.model, newdata = x.test)) # predict on trained model
    bivar.null.lm.model<-lm(as.formula(fml.null), data = x.train) # create null model for hypothesis testing and for calculating RSS0
    val.null.pred[[l]] = c(val.null.pred[[l]], predict(bivar.null.lm.model, newdata = x.test)) # predict on null model
    # t<- anova(bivar.null.lm.model, bivar.lm.model) # to get p-values for model
    # p.value[[l]] <- as.numeric(t[2,][["Pr(>F)"]])  # to get p-values for model
  }
}
num.test.obs <- lapply(num.true, sum.vectors.in.list)

rsq.vitals = c()
rssm.vitals = c()
rss0.vitals = c()
pct.var.explained = c()
num.Records.check <- c()
for (j in 1:length(top.names)){
  rsq.vitals = c(rsq.vitals, cor(val.pred[[j]], val.true[[j]], use = "complete.obs"))
  rssm.vitals = sum(na.omit((val.true[[j]] - val.pred[[j]])^2))
  rss0.vitals = sum(na.omit((val.true[[j]] - val.null.pred[[j]])^2))
  pct.var.explained = c(pct.var.explained, (1 - ( rssm.vitals / rss0.vitals )))
  num.Records.check <- c(num.Records.check, (length(val.pred[[j]])-1)) # same as num.test.obs
}
names(rsq.vitals) = top.names
names(pct.var.explained) = top.names
sqrt.pct.var <- sqrt(pct.var.explained)

####
# CODE FOR LASSO, RF

#clean wear data frame
wear[,8:length(names(wear))] <- apply(
  wear[,8:length(names(wear))], 2,
  function(x) as.numeric(as.character(x)))
wear$Gender <- as.factor(wear$Gender)
wear$Ethn <- as.factor(wear$Ethn)
wear.variables <- unlist(read.table("FinalLasso_153WearableFactors.csv", stringsAsFactors = FALSE)) # the table of model features we want to work with
demo.variables <- c("AgeIn2016", "Gender", "Ethn")

val.true <- rep(list(NA),length(top.names)) # list of vectors to store true values; each vector is for 1 clinical lab
null.val.pred <- rep(list(NA),length(top.names))  # list of vectors to store nullmodel-predicted values; each vector is for 1 clinical lab
lasso.val.pred <- rep(list(NA),length(top.names)) # list of vectors to store lasso-trainedmodel-predicted values; each vector is for 1 clinical lab
rf.val.pred <- rep(list(NA),length(top.names))  # list of vectors to store rf-trainedmodel-predicted values; each vector is for 1 clinical lab
num.Records <- c()
for (k in 1:length(patients)){
  train <- patients[patients != patients[k]]
  test <- patients[patients == patients[k]]
  cat("Patient",patients[k],"\n") # LOO
  dat.train<- wear[ wear$iPOP_ID %in% train, ] # subset input data by training set
  dat.test<-wear[ wear$iPOP_ID %in% test, ] # subset input data by testing set
  for (l in 1:length(top.names)){
    cat("Test",top.names[l],"\n")
    x.train<-dat.train[,colnames(dat.train) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
    x.train<- na.omit(x.train) # skip nas and nans ## TODO: the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
    predictors <- as.data.frame(x.train[,colnames(x.train) %in% c(wear.variables, demo.variables)]) # later add in demographics
    outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
    
    # create test set
    x.test<-dat.test[,colnames(dat.test) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
    x.test<- na.omit(x.test) # skip nas and nans ## TODO: SEE ABOVE na.omit FOR ISSUE WITH THIS
    val.true[[l]] = c(val.true[[l]], x.test[,top.names[l]]) # true values of left out person
    
    num.Records <- rbind(num.Records, c(IPOP_ID=patients[k], test=top.names[l], TrainingObs=length(outcome), TestObs=length(x.test[,top.names[l]])))
    
    rf.variables.to.use = c(wear.variables, demo.variables) # rf variables (use all)
    
    ## run lasso for variable selection
    n <- as.numeric(length(outcome)) #optional argument for leave-one-out CV method for nfold
    x_train <- model.matrix( ~ .-1, as.data.frame(predictors))
    glm.res = cv.glmnet(x=x_train,y=outcome,
                        standardize.response=FALSE,
                        family="gaussian",
                        nfolds=n,
                        nlambda=100)
    lasso.variables.to.use = rownames(glm.res$glmnet.fit$beta[abs(glm.res$glmnet.fit$beta[,25]) > 1e-10,]) # TODO: this is an arbitrary rule for now
    # check if Gender* / Ethn* selected into LASSO models
    ethn.sel = grep("^Ethn",lasso.variables.to.use)
    gend.sel = grep("^Gender",lasso.variables.to.use)
    
    # remove Gender* and add Gender if present
    # remove Ethn* and add Ethn if present
    torm = c(ethn.sel, gend.sel)
    if (length(torm) > 0){
      lasso.variables.to.use = lasso.variables.to.use[-torm]
      if (length(ethn.sel) > 0){
        lasso.variables.to.use = c("Ethn",lasso.variables.to.use) }
      if (length(gend.sel) > 0){
        lasso.variables.to.use = c("Gender",lasso.variables.to.use) # variables.to.use contains all variables selected by LASSO    
      }        
    }
    
    # build null, lasso, and rf models
    set.seed(1)
    null.fml = paste(top.names[l]," ~ 1")
    null.model = lm(as.formula(null.fml), data = x.train) # create null model for hypothesis testing and for calculating RSS0
    null.val.pred[[l]] = c(null.val.pred[[l]], predict(null.model, newdata = x.test)) # predict on null model
    
    lasso.fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(lasso.variables.to.use,collapse=" + "))
    lasso.model = lm(as.formula(lasso.fml), data = x.train) # , weights = labs.wear$weight) # TODO: do we need to include weights?
    lasso.val.pred[[l]] = c(lasso.val.pred[[l]], predict(lasso.model, newdata = x.test)) # predict on trained model
    
    rf.fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(rf.variables.to.use,collapse=" + "))
    rf.model = randomForest(as.formula(rf.fml), data = x.train)  #weights = labs.wear$weight) # TODO: do we need to include weights?
    rf.val.pred[[l]] = c(rf.val.pred[[l]], predict(rf.model, newdata = x.test)) # predict on left out person
    
    # t<- anova(bivar.null.lm.model, bivar.lm.model) # to get p-values for model
    # p.value[[l]] <- as.numeric(t[2,][["Pr(>F)"]])  # to get p-values for model
  }
}

## calculate correlation coefficients and pct var explained by the models
rsq.lasso = c()
rssm.lasso = c()
rss0.lasso = c()
lasso.pct.var.explained = c()
lasso.num.Records <- c()
rsq.rf = c()
rssm.rf = c()
rss0.rf = c()
rf.pct.var.explained = c()
rf.num.Records <- c()

for (j in 1:length(top.names)){
  #lasso
  rsq.lasso = c(rsq.lasso, cor(lasso.val.pred[[j]], val.true[[j]], use = "complete.obs"))
  rssm.lasso = sum(na.omit((val.true[[j]] - lasso.val.pred[[j]])^2))
  rss0.lasso = sum(na.omit((val.true[[j]] - null.val.pred[[j]])^2))
  lasso.pct.var.explained = c(lasso.pct.var.explained, (1 - ( rssm.lasso / rss0.lasso )))
  lasso.num.Records <- c(num.Records, length(lasso.val.pred[[j]]))
  #rf
  rsq.rf = c(rsq.rf, cor(rf.val.pred[[j]], val.true[[j]], use = "complete.obs"))
  rssm.rf = sum(na.omit((val.true[[j]] - rf.val.pred[[j]])^2))
  rss0.rf = sum(na.omit((val.true[[j]] - null.val.pred[[j]])^2))
  rf.pct.var.explained = c(rf.pct.var.explained, (1 - ( rssm.rf / rss0.rf )))
  rf.num.Records <- c(num.Records, length(rf.val.pred[[j]]))
  
}
names(rsq.lasso) = top.names
names(lasso.pct.var.explained) = top.names
lasso.sqrt.pct.var <- sqrt(lasso.pct.var.explained)

names(rsq.rf) = top.names
names(rf.pct.var.explained) = top.names
rf.sqrt.pct.var <- sqrt(rf.pct.var.explained)

fig.2c.df <- cbind(rownames(as.data.frame(sqrt.pct.var)), as.data.frame(sqrt.pct.var), as.data.frame(lasso.sqrt.pct.var), as.data.frame(rf.sqrt.pct.var), row.names=NULL)

colnames(fig.2c.df)<-c("test", "vitals", "lasso", "rf")
fig.2c.df$test = factor(fig.2c.df$test, levels = as.factor(names(sqrt.pct.var)[order(-sqrt.pct.var)]))

fig.2c.corr.coefs <- cbind(rownames(as.data.frame(rsq.vitals)), as.data.frame(rsq.vitals), as.data.frame(rsq.lasso), as.data.frame(rsq.rf), row.names=NULL)
colnames(fig.2c.corr.coefs)<-c("test", "vitals", "lasso", "rf")
fig.2c.corr.coefs$test = factor(fig.2c.corr.coefs$test, levels = as.factor(names(rsq.vitals)[order(-rsq.vitals)]))
fig.2c.corr.coefs[fig.2c.corr.coefs<0]=0 # clamp to zero

fig.2c.plot <- melt(fig.2c.corr.coefs)
fig.2c.plot[,3][is.nan(fig.2c.plot[,3])] <- 0 #replace % var explained of NaN w/ 0
fig.2c <- fig.2c.plot[order(-fig.2c.plot[,3]),] # reorder by LM Vitals

num.Records <- as.data.frame(num.Records)
num.Records <- transform(num.Records, TrainingObs = as.numeric(TrainingObs), 
               TestObs = as.numeric(TestObs))

# Plot the % var explained
ggplot(fig.2c, aes(x=test, y=value, color = variable)) + geom_point(size = 5, aes(shape=variable, color=variable)) +
  weartals_theme +
  ylim(0,1) +
  scale_shape_discrete(breaks=c("vitals", "lasso", "rf"),
                       labels=c("LM vitals", "LASSO", "RF")) +
  scale_color_discrete(breaks=c("vitals", "lasso", "rf"),
                       labels=c("LM vitals", "LASSO", "RF")) +
  labs(x = "Lab tests",y = expression(paste("Sqrt of % Variance Explained"))) 

# store the results
write.table(num.Records, "../SECURE_data/20180506_num_Records_DayPrior.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(fig.2c.df, "../SECURE_data/20180506_pct_var_Dayprior.csv",row.names=FALSE,col.names=c("test", "vitals", "lasso", "rf"), sep=",")
write.table(fig.2c.corr.coefs, "../SECURE_data/20180506_corr_coefs_Dayprior.csv",row.names=FALSE,col.names=c("test", "vitals", "lasso", "rf"), sep=",")
write.table(num.Records, "../SECURE_data/20180507/20180507_Dayprior_num_Records.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(num.Records.check, "../SECURE_data/20180507/20180507_Dayprior_num_Records_check.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(rf.num.Records.check, "../SECURE_data/20180507/20180507_Dayprior_RF_num_Records.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(lasso.num.Records, "../SECURE_data/20180507/20180507_Dayprior_LASSO_num_Records.csv",row.names=FALSE,col.names=FALSE, sep=",")

####################################
#   Figure 2C Timecourse / 5 (??)  #
####################################
#Run after running individual time course from 2C (reading in various files for wear by timespans) that produced pct_var, corr_coeffs, & num_Records files   #
weartals_theme = theme_bw() + theme(text = element_text(size=18), panel.border = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))
# read in each of the corr_coeffs from the different time windows
# had to manually add back in headers in the with demog files that I ran on scg: 20180327_corr_coeffs_AllData.csv , 20180327_corr_coeffs_MonthPrior.csv, 20180327_corr_coeffs_TwoWeekPrior.csv, 20180327_corr_coeffs_WeekPrior.csv,20180327_corr_coeffs_DayPrior.csv, 20180327_corr_coeffs_ThreeDayPrior.csv, 
# save as pdf 4x12.5"
# data <-read.table("/Users/jessilyn/Desktop/framework_timecourse/with_resting_bugfix_and_demographics/20180420_corr_coeffs_AllData_demog.csv",
#                   header=TRUE,sep=',',stringsAsFactors=FALSE)
fig.2c.df <-read.csv("/Users/jessilyn/Desktop/framework_timecourse/with_restingbugfix_demog_pctdev/20180507_AllData_pct_var.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)
fig.2c.plot <- melt(fig.2c.df)
fig.2c.plot[,3][is.nan(fig.2c.plot[,3])] <- 0 #replace % var explained of NaN w/ 0
fig.2c$test <- fig.2c.plot[order(-fig.2c.plot[,3]),] # reorder by LM Vitals
fig.2c$test = factor(fig.2c$test, levels = order(-fig.2c.plot[,3]))

# Plot the % var explained
ggplot(fig.2c, aes(x=test, y=value, color = variable)) + geom_point(size = 5, aes(shape=variable, color=variable)) +
  weartals_theme +
  ylim(0,1) +
  scale_shape_discrete(breaks=c("vitals", "lasso", "rf"),
                       labels=c("LM vitals", "LASSO", "RF")) +
  scale_color_discrete(breaks=c("vitals", "lasso", "rf"),
                       labels=c("LM vitals", "LASSO", "RF")) +
  labs(x = "Lab tests",y = expression(paste("Sqrt of % Variance Explained"))) 


### THE PART BELOW IS UNDER CONSTRUCTION
# Look at differences between DayPrior and AllData
data.allData <-read.table("/Users/jessilyn/Desktop/framework_timecourse/with_restingbugfix_demog_pctdev/20180503_pct_var_Dayprior.csv",
                          header=TRUE,sep=',',stringsAsFactors=FALSE)
data.dayPrior <-read.table("/Users/jessilyn/Desktop/framework_timecourse/with_restingbugfix_demog_pctdev/20180507_AllData_pct_var.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)
#data.dayPrior$model<- gsub("vitals", "vitals.ipop", data$model)
#data$r_squared <- pmax(data$r_squared, 0)
#data.nodemog$r_squared <- pmax(data$r_squared, 0)
#df <- merge(data.dayPrior, data.allData, by = c("model", "test"))
#colnames(df)[3:4] <- c("DayPrior", "AllData")
df <- data.dayPrior[,3:4] - data.allData[,3:4]
df2 <- melt(df)
df2<- df2[order(-df2$value),]
df2<-cbind(data.dayPrior[,1], df2)
colnames(df2)<-c("test", "model", "pct.var")
ggplot(df2, aes(test,pct.var, color = model)) + geom_point(size = 5, aes(shape=model, color=model)) +
  weartals_theme + 
  ylim(-0.5,0.5) +
  scale_shape_discrete(breaks=c("rf", "lasso"),
                       labels=c("RF", "LASSO")) +
  scale_color_discrete(breaks=c("rf", "lasso"),
                       labels=c("RF", "LASSO")) +
  labs(x = "Lab tests",y = expression(atop("Increase in Corr Coeff", paste("by using Day Prior vs All Watch Data"))))

### THE PART BELOW IS UNDER CONSTRUCTION
# make the case that if we could do the RF etc on all data (dont need to be individualized models) and we could combine the individualized models we could do an awesome job at preciting the clinical labs.
# can we create one more layer of mixed effects models in the iPOP analysis here?

# Look at differences between with and without demog
data.nodemog <-read.table("/Users/jessilyn/Desktop/framework_timecourse/with_resting_bugfix_no_demographics/20180420_corr_coeffs_TwoWeekPrior.csv",
                          header=TRUE,sep=',',stringsAsFactors=FALSE)
data <-read.table("/Users/jessilyn/Desktop/framework_timecourse/with_resting_bugfix_and_demographics/20180420_corr_coeffs_TwoWeekPrior_demog.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)
data$model<- gsub("vitals", "vitals.ipop", data$model)
#data$r_squared <- pmax(data$r_squared, 0)
#data.nodemog$r_squared <- pmax(data$r_squared, 0)
df <- merge(data, data.nodemog, by = c("model", "test"))
colnames(df)[3:4] <- c("r_w_demog", "r_no_demog")
df$delta <- df[,3] - df[,4]
df<- df[order(-df$delta),]

ggplot(df, aes(test,delta, color = model)) + geom_point(size = 5, aes(shape=model, color=model)) +
  weartals_theme + 
  ylim(-0.5,0.5) +
  scale_shape_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  scale_color_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  labs(x = "Lab tests",y = expression(atop("Increase in Corr Coeff", paste("by adjusting for demographics"))))



################################################
#  Figure 2E  - Canonical Correlation Analysis #
################################################

# should we make this regularized - what is the right proportion between observations and features to decide this (I think there we have ~2X the numver of obs as features)

# library("devtools)
# install_url("https://cran.r-project.org/src/contrib/Archive/impute/impute_1.26.0.tar.gz")
# install.packages("PMA)

library("PMA")
library("Hmisc")
clinical.groups = list()
clinical.groups[["Electrolytes"]] =c("CA","K","CL","CO2","NA.","AG")
clinical.groups[["Diabetes"]] =c("A1C","ALB","GLU","UALB","CR","ALCRU")
#clinical.groups[["Cardiovascular.Disease"]]=c("CHOL","LDLHDL","HDL","CHOLHDL","NHDL","TGL","LDL")
clinical.groups[["Liver Function"]]=c("ALKP","BUN","ALT","TBIL","AST")
clinical.groups[["Inflammation"]]=c("BASO","LYM","LYMAB","MONO","MONOAB","NEUT","NEUTAB","IGM","EOS","EOSAB","BASOAB","WBC","HSCRP")
clinical.groups[["Blood"]] = c("PLT","GLOB","TP","HGB","HCT","RDW","MCH","MCV","RBC","MCHC")
#clinical.groups[["Cardiometabolic.Disease"]]=c("A1C","ALB","GLU","UALB","CR","ALCRU","CHOL"," LDLHDL","HDL","CHOLHDL","NHDL","TGL","LDL")
cca.corr.coefs <- c()
patients <- unique(wear$iPOP_ID)

#wear$LDL = as.numeric(wear$LDL)

for (nm in names(clinical.groups)){
  print(nm)
  # Remove rows with NAs
  data.clin = wear[,which(colnames(wear) %in% c("iPOP_ID", clinical.groups[[nm]]))]
  data.wear = wear[,which(colnames(wear) %in% wear.variables)]
  d <- cbind(data.clin, data.wear)
  d <- na.omit(d)
  iPOP.idx <- d[,1]
  d<-d[-1]
  # remove correlated columns
  tmp <- cor(d)
  tmp[upper.tri(tmp)] <- 0
  diag(tmp) <- 0
  d <- d[,!apply(tmp,2,function(x) any(x > 0.99999999999))] # how does it choose which variable to get rid of? Does it matter which one bc they are linear combos of eachother?

  d = scale(d,scale = FALSE) # why scale it?
  indexX = c()
  indexY = c()
  
  # leave one person out CV
  for (i in 1:length(patients)){
    train <- d[!iPOP.idx %in% patients[i],,drop=FALSE]
    test <- d[iPOP.idx %in% patients[i],,drop=FALSE]
    if (nrow(test) != 1){ #maybe make this > 0?

  # build the CCA model
  model.cc = CCA(train[,(ncol(data.clin)):(ncol(train))],  # TODO: cehck that this is choosing the correct columns for the right and left hand sides
                train[,1:(ncol(data.clin)-1)],trace = FALSE,K=1)

  #plug in test data using coefficients from CCA model and compare right and left sides
  indexX = c(indexX, as.matrix(test[,(ncol(data.clin)):(ncol(test))]) %*% model.cc$u)
  indexY = c(indexY, as.matrix(test[,1:(ncol(data.clin)-1)]) %*% model.cc$v)
  
  #cca.corr <- cor(indexX, indexY)
  #print(model.cc$cor[1])
  #cca.corr.coefs <- rbind(cca.corr.coefs, c(nm, model.cc$cor[1], patients[i]))
  #cca.corr.coefs <- rbind(cca.corr.coefs, c(nm, cca.corr, patients[i]))
    }
  }
  cca.corr <- cor(indexX, indexY)
  print(ggplot(data.frame(indexX = indexX, indexY = indexY),aes(indexX,indexY)) +
    weartals_theme +
    geom_point() +
    ggtitle(nm) +
    stat_summary(fun.data=mean_cl_normal) +
    geom_smooth(method='lm',formula=y~x))
  print(cca.corr)
}
# library(dplyr)
# data <- (cca.corr.coefs %>%
#                        group_by(nm) %>% 
#                        summarise_at(vars("cca.corr"), funs(mean,sd)))
ggplot(data, aes(x=nm, y=mean)) +
  theme(legend.title = element_blank()) +
  geom_point() +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1)) +
  #ylim(0,0.5) +
  labs(x = "Physiology Subsets", y ="Correlation Coefficient")
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.5)

##############
#  Figure 3A #
##############

hist(table(corDf$ANON_ID), col="darkgrey", breaks=1000, xlab = "Number of Clinic Visits",
     main = NULL, font.lab=2,lwd=2,font=2) # dist. of clinic visits in 30k cohort
hist(table(corDf$ANON_ID)[table(corDf$ANON_ID)>50], col="darkgrey", breaks=1000, xlab = "Number of Clinic Visits",
     main = NULL, font.lab=2,lwd=2,font=2) # dist. of clinic visits in 30k cohort
describe(as.matrix(table(corDf$ANON_ID))) # mean & median number visits in 30k cohort
# duration of time monitored in 30K dataset:
maxDate <-as.Date(as.matrix(tapply(corDf$Clin_Result_Date, corDf$ANON_ID, max)))
minDate <- as.Date(tapply(corDf$Clin_Result_Date, corDf$ANON_ID, min))
duration <- as.numeric(maxDate-minDate)
describe(duration) # mean & median number of days of monitoring in 30k cohort
hist(duration[duration > 50], col="darkgrey", breaks=1000, xlab = "Time Period Monitored (Days)",
     main = NULL, font.lab=2,lwd=2,font=2)

#characterize the 30k data set
length(unique(corDf$ANON_ID)) # num people in 30k dataset where both labs and vitals exist
length(unique(labs$ANON_ID)) # num people in 30k dataset
length(na.omit(labs$Clin_Result_Date)) # num lab tests (in the 50 labs we explored) in 30k dataset
as.matrix(table(labs$LAB_NAME)) # number of each clinical lab
length(na.omit(vitals$Temp)) + length(na.omit(vitals$Pulse)) # total number of clinical vital signs measured
#304 people have more than 50 observations per person
length(table(corDf$ANON_ID)[table(corDf$ANON_ID)>50])

########################
#  Figure 3A 3D and 3E #
########################
#30 K Univariate Correlation Fit Plots by Lukasz/Jessie
vitalVars <- which(names(corDf) %in% c("Pulse","Temp"))
allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EOS","EOSAB","ESR", "GLOB","GLU_byMeter",
             "GLU_fasting","GLU_nonFasting","GLU_SerPlas",
             "GLU_wholeBld","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL_Calc", "LDL_Direct","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT","PROCALCITONIN", "RBC","RDW","TBIL","TGL","TP","TroponinI","WBC")
clinVars <- which(names(corDf) %in% allClin)
#clin subset of the top 10 most predictive models from bivariate analysis:
# clinTopTen <- c("GLU_fasting","CR","HSCRP", "NEUTAB","NEUT","LYM", "RDW","ALB","AG", "PLT","PROCALCITONIN", "ESR")
# clinTopTen <- c("NA." , "NEUT", "HSCRP", "RBC", "LDLHDL", "ALB", "NHDL", "HGB", "GLU_fasting", "CL", "LYM")
clin.WBCs<- c("NEUT", "LYM", "BASO","MONO","EOS",
              "NEUTAB", "LYMAB", "BASOAB","MONOAB","EOSAB",) 
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()
plots <- list()
idx=0
for (j in clin.WBCs){
  idx=idx+1
  ## 30k All data scatterplots for Fig 3D and 3E
  pname <- paste0("Plot-",i)
  p<-ggplot(corDf, aes_string(y = corDf[[j]], x = corDf$Pulse)) +
    #ggplot(corDf, aes(y = corDf[[j]], x = corDf$Temp)) +
    stat_density_2d(aes(fill = ..level..), geom = 'polygon') +
    #scale_fill_viridis_c(name = "density") +
    geom_point(shape = '.') +
    stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
    theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
    ylab(paste0(c(j ," Bin")))+
    xlab("cHR")
  ggsave(paste0(pname,".png"),p)
  plots[[idx]] = p   
}
p <- grid.arrange(grobs=plots,ncol=5)

clin.WBCs<- c("NEUT", "LYM", "BASO","MONO","EOS",
              "NEUTAB", "LYMAB", "BASOAB","MONOAB","EOSAB") 
#clin.WBCs<- c("HSCRP")
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()


## All points with curves
plots <- list()
idx=0
for (j in clin.WBCs){
  idx=idx+1
  ## 30k All data scatterplots for Fig 3D and 3E
  #pname <- paste0("Plot-",i)
  p<-ggplot(
    corDf, aes_string(y = corDf[[j]], x = corDf$Pulse)) +
    #corDf, aes_string(y = corDf[[j]], x = corDf$Temp)) +
    stat_density_2d(aes(fill = ..level..), geom = 'polygon') +
    #scale_fill_viridis_c(name = "density") +
    geom_point(shape = '.') +
    stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
    theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
    ylab(paste0(c(j ," Bin")))+
    xlab("cHR")
  #ggsave(paste0(pname,".png"),p)
  plots[[idx]] = p   
}

p <- grid.arrange(grobs=plots,ncol=5)

## Just the binned curves
plots1 <- list()
plots2 <- list()
idx=0
for (j in clin.WBCs){
  idx=idx+1
  corDf$bin2<-ntile(corDf[[j]], 40)
  # for Temp - point plot of bin values (looks like line of points)
  # corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  # p1<- ggplot(corDf2, aes(x=bin2, y=Temp)) +
  #   geom_point(stat="identity", fill="darkblue") +
  #   geom_errorbar(aes(ymin=Temp-se, ymax=Temp+se), width=.4) +
  #   xlab(paste(c(j, "bins", sep=" ")))+
  #   scale_y_continuous(limits = c(97,99))+
  #   theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1))
  # # For Pulse
  corDf2 <- summarySE(corDf, measurevar="Pulse", groupvars="bin2", na.rm=TRUE)
  # barplot of bin values (looks like the line of points but with bars instead)
  # p1 <- ggplot(corDf2, aes(x=bin2, y=Pulse)) +
  #   geom_bar(stat="identity", fill="darkred") +
  #   geom_errorbar(aes(ymin=Pulse-se, ymax=Pulse+se), width=.2) +
  #   xlab(paste(c(j, "bins", sep=" "))) +
  #   theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1))
  # print(paste0(j, ": number of data points in bin = ", sum(corDf$bin2 %in% "2")))
  # quadratic models of bins
  model <-lm(corDf2$Pulse  ~ corDf2$bin2 + I((corDf2$bin2)^2))
  p1 <- ggplot(corDf2, aes(y = bin2, x = Pulse)) +
    stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
    theme(axis.title=element_text(face="bold",size="11"), axis.text.x = element_text(angle = 60, hjust = 1), axis.text=element_text(size=11,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
    #geom_point(col="black") +
    ylab(paste0(c(j ," Bin")))
  # summary.pulse <- summary(lm(corDf2$Pulse ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # r.squared[j] <- summary.pulse$adj.r.squared
  corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  p2<-ggplot(corDf2, aes(y = bin2, x = Temp)) +
    stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkblue") +
    #geom_point(col="black") +
    #ylim(c(96,98.5))+
    theme(axis.title=element_text(face="bold",size="11"), axis.text.x = element_text(angle = 60, hjust = 1), axis.text=element_text(size=11,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
    ylab(paste0(c(j ," Bin")))
  # # summary.Temp <- summary(lm(corDf2$Temp ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # # r.squared[j] <- summary.Temp$adj.r.squared
  plots1[[idx]] = p1
  plots2[[idx]] = p2
}
p <- grid.arrange(grobs=plots1,ncol=5)
p2 <- grid.arrange(grobs=plots2,ncol=5)
as.matrix(r.squared)


##############
#  Figure 3B #
##############

hist(corDf$Pulse, col="darkred", breaks=100,
     xlab = "cHR",
     main = NULL, font.lab=2,lwd=2,font=2)

hist(corDf$Temp, col="darkgrey", breaks=100,
     xlab = "cTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)

#####################
#  Figure 3F and 3G #
#####################

#for (i in clinTopTen){
i <- "NEUT"
pulse.diff <- c()
temp.diff <- c()
pulse.fourth.quartile <- c()
pulse.num.fourth.quartile <- c()
pulse.third.quartile <- c()
pulse.num.third.quartile <- c()
pulse.second.quartile <- c()
pulse.num.second.quartile <- c()
pulse.first.quartile <- c()
pulse.num.first.quartile <- c()
temp.fourth.quartile <- c()
temp.num.fourth.quartile <- c()
temp.third.quartile <- c()
temp.num.third.quartile <- c()
temp.second.quartile <- c()
temp.num.second.quartile <- c()
temp.first.quartile <- c()
temp.num.first.quartile <- c()
idx=0
ptm <- proc.time()
for (j in unique(corDf$ANON_ID)){
  idx=idx+1
  #create personalized quartiles for each person/measurement type; this step takes a very very long time
  person <- corDf[corDf$ANON_ID == j,]
  if (sum(!is.na(person[,i])) >= 4 & sum(!is.na(person$Pulse)) >= 4){
    print(paste0(idx, " : ", j))
    person$bins2 <- ntile(person[,i], 4)
    #get pulse values when the lab measurement for that person is in their lowest or highest quartile
    pulse.fourth.quartile[j] <- mean(person$Pulse[person$bins2 >= 4])
    pulse.num.fourth.quartile[j] <-length(person$Pulse[person$bins2 >= 4 ])
    pulse.third.quartile[j] <- mean(person$Pulse[person$bins2 >= 3  &  person$bins2 < 4 ])
    pulse.num.third.quartile[j] <- length(person$Pulse[person$bins2 >= 3  &  person$bins2 < 4 ])
    pulse.second.quartile[j] <- mean(person$Pulse[person$bins2 >= 2  &  person$bins2 < 3 ])
    pulse.num.second.quartile[j] <- length(person$Pulse[person$bins2 >= 2  &  person$bins2 < 3 ])
    pulse.first.quartile[j] <- mean(person$Pulse[person$bins2 <= 1 ])
    pulse.num.first.quartile[j] <-length(person$Pulse[person$bins2 <= 1 ])
    # make a way to save this for each i
    
    #get temp values when the lab measurement for that person is in their lowest or highest quantile
    temp.fourth.quartile[j] <- mean(person$Temp[person$bins2 >= 4 ])
    temp.num.fourth.quartile[j] <-length(person$Temp[person$bins2 >= 4 ])
    temp.third.quartile[j] <- mean(person$Temp[person$bins2 >= 3  &  person$bins2 < 4 ])
    temp.num.third.quartile[j] <- length(person$Temp[person$bins2 >= 3  &  person$bins2 < 4 ])
    temp.second.quartile[j] <- mean(person$Temp[person$bins2 >= 2  &  person$bins2 < 3 ])
    temp.num.second.quartile[j] <- length(person$Temp[person$bins2 >= 2  &  person$bins2 < 3 ])
    temp.first.quartile[j] <- mean(person$Temp[person$bins2 <= 1 ])
    temp.num.first.quartile[j] <-length(person$Temp[person$bins2 <= 1 ])
    # make a way to save this for each i
    
  }
}
proc.time() - ptm

personalQuartiles<-cbind(as.matrix(pulse.first.quartile), as.matrix(pulse.second.quartile), as.matrix(pulse.third.quartile),as.matrix(pulse.fourth.quartile),
                         as.matrix(temp.first.quartile), as.matrix(temp.second.quartile), as.matrix(temp.third.quartile), as.matrix(temp.fourth.quartile))
personalQuartiles <- personalQuartiles[(!is.na(personalQuartiles[,2]) & !is.na(personalQuartiles[,5])),] #remove NAs
#names(personalQuartiles) <- c("pulse.first.quartile", "pulse.second.quartile", "pulse.third.quartile", "pulse.fourth.quartile", "temp.first.quartile", "temp.second.quartile", "temp.third.quartile","temp.fourth.quartile")
pulse.diff<-as.matrix(personalQuartiles[,4] - personalQuartiles[,1])
hist(pulse.diff, breaks=100, col="darkred", main=paste0("Mean Pulse (1st - 4th quartile of ",i, " values)"))
boxplot(pulse.diff, col="darkred", outline=FALSE, main=paste0("Mean Pulse (1st - 4th quartile of ",i, " values)"))
temp.diff<-as.matrix(personalQuartiles[,8] - personalQuartiles[,5])
hist(temp.diff, breaks=100, col="darkblue", main=paste0("Mean Temp (1st - 4th quartile of ",i, " values)"))
boxplot(temp.diff, col="darkblue", outline=FALSE, main=paste0("Mean Temp (1st - 4th quartile of ",i, " values)"))


# data in play: temp.diff.neut and pulse.diff.neut and temp.diff.lym and pulse.diff.lym
hist(temp.diff.neut, breaks=100, main="Temperature Difference Between Personalized  4th and 1st Quartile of Neutrophil Levels", xlab="Temperature Difference", ylab="Number of Individuals", border="black", col="darkblue")
hist(pulse.diff.neut, breaks=100, main="Pulse Difference Between Personalized 4th and 1st Quartile of Neutrophil Levels", xlab="Pulse Difference", ylab="Number of Individuals", border="black", col="darkred")
hist(temp.diff.lym, breaks=100, main="Temperature Difference Between Personalized 4th and 1st Quartile of Lymphocyte Levels", xlab="Temperature Difference", ylab="Number of Individuals", border="black", col="darkblue")
hist(pulse.diff.lym, breaks=100, main="Pulse Difference Between Personalized 4th and 1st Quartile of Lymphocyte Levels", xlab="Pulse Difference", ylab="Number of Individuals", border="black", col="darkred")

write.csv(temp.diff.lym, "~/Desktop/tempdifflym.csv")
write.csv(pulse.diff.lym, "~/Desktop/pulsedifflym.csv")

length(temp.diff.neut[!is.na(temp.diff.neut)])
#  }
#}

##########################################
#    Fig 3C; Suppl. Table 2 and 3        #
##########################################
# create ranked list of clinical laboratory tests by the correlation coefficients between observed and predicted values; checked by Jessie on 2017-12-20
# predicted values from simple bivariate models of (lab test ~ pulse + temp) using 30k dataset
# Do 10-fold cross validation at the subject level (e.g. each test set contains 1/10 of the people in the 28k dataset)
# RUN 30K CORRELATIONS between labs and vitals

names(corDf)[names(corDf) %in% "GLU_SerPlas"] <-"GLU"  # fix names to be same between iPOP and 30K datasets ; number of NAs for each GLU: GLU_nonFasting (113472), GLU_wholeBld (111726), GLU_SerPlas (30949), GLU_byMeter (NA = 101012), GLU_fasting (110303)
names(corDf)[names(corDf)  %in% "LDL_Calc"] <-"LDL"  # fix names to be same between iPOP and 30K datasets ; corDf$LDL_Calc range = wear$LDL range
options("scipen"=100, "digits"=4)
models=c(" ~ Pulse", # univariate with pulse only
         " ~ Temp",   # univariate with temp only
         " ~ Pulse + Temp", # bivariate with pulse + temp
         " ~ Pulse + I(Pulse^2)",
         " ~ Temp + I(Temp^2)", " ~ Pulse + I(Pulse^2) + Temp + I(Temp^2)" )
cv.runs <- 50
models.corr.coefs <- c()
models.pct.var <- c()

for (i in 1:cv.runs){ #50 fold cross validation (10% test set; 90% training set)
  print(i)
  ANON_ID = corDf$ANON_ID # Remember the list of subjects
  corDf.tmp = corDf[,-c(1,2)]  #remove ANON_ID and Clin_Result_Date
  corDf.tmp <- subset(corDf.tmp, select=-c(ALCRU, CR)) # all values for ALCRU tests are NA, only 20 values for CR are not NA
  nms = names(subset(corDf.tmp, select=-c(Pulse, Temp)))

  # Do cross-validation
  subjects = unique(ANON_ID)
  n = length(subjects) # total num of observations
  test = sample(n)[1:floor(n*0.1)] # 10% of subjects are held for testing
  test.subj = subjects[test]
  test.mask = ANON_ID %in% test.subj

    for (nm in top.names){ # for each of the 50 clinical lab tests
      print(nm)
      tmp=0
      corDf2 = data.frame(labtest = corDf.tmp[[nm]], Pulse = corDf.tmp$Pulse, Temp = corDf.tmp$Temp) # prepare data for LM
      #df <- cbind(corDf2[[i]], corDf2[,c("Pulse", "Temp")])
      corDf2 <- na.omit(corDf2)
      test.data <- na.omit(corDf2[test.mask,])
      train.data <-na.omit(corDf2[!test.mask,])
        for (k in 1:length(models)){
          model<-lm(as.formula(paste0("labtest",models[k])),data=train.data)
          m <- summary(model) # quadratic univariate with pulse or temp only
          model.null <- lm(as.formula(paste0("labtest"," ~ 1")),data=train.data)
          # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
          # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
          numTrainObs<-length(train.data$Pulse) # train: the number of each clinical lab test that has corresponding vital signs
          numTestObs<-length(test.data[,1]) #  test: the number of each clinical lab test that has corresponding vital signs
          pred=predict(model, newdata=test.data)# prediction on test data set
          pred.null=predict(model.null, newdata=test.data)# prediction on test data set
          #rsq.pred = 1 - (mean( pred - test.data[,1])**2 ) / var( (test.data[,1]) ) # test r.sq
          if (length(pred)<1){next}
          r.pred = cor(pred, test.data[,1], use = "complete.obs") # test r.sq
          rssm <- sum((test.data[,1] - pred)^2)
          rss0 <- sum((test.data[,1]- pred.null)^2)
          sqrt.pct.var <- sqrt(1- (rssm/rss0))
          name.rsq <- paste("model.mean.rsq", k, sep = ".")
          models.corr.coefs <- rbind(models.corr.coefs,
                                     c(model = name.rsq, cv.step = i, test = nm, corr.coef = r.pred, sqrt.pct.var = sqrt.pct.var, numTestObs = numTestObs, numTrainObs = numTrainObs))
    }
  }
}

# models.corr.coefs <-read.csv("/Users/jessilyn/Desktop/framework_paper/Figure3/Fig3C/20180503_pct_var_30k_noDemog.csv")
corr.coefs <- as.data.frame(models.corr.coefs)
corr.coefs$cv.step <- as.numeric(as.character(corr.coefs$cv.step))
corr.coefs$corr.coef <- as.numeric(as.character(corr.coefs$corr.coef))
corr.coefs$sqrt.pct.var <- as.numeric(as.character(corr.coefs$sqrt.pct.var))

library(dplyr)
model.corr.coefs <- (corr.coefs %>%
  group_by(test, model) %>% 
  summarise_at(vars("sqrt.pct.var"), funs(mean,sd)))
model.corr.coefs$model <- mapvalues(model.corr.coefs$model, from = c("model.mean.rsq.1", "model.mean.rsq.2", "model.mean.rsq.3", "model.mean.rsq.4", "model.mean.rsq.5", "model.mean.rsq.6"), to = c("~ Pulse", "~ Temp", "~ Pulse + Temp", " ~ Pulse + P^2", " ~ Temp + T^2", " ~ Pulse + P^2 + Temp + T^2"))
model.corr.coefs <- na.omit(model.corr.coefs)
model.corr.coefs$test  = factor(model.corr.coefs$test, levels=pull(model.corr.coefs[order(-model.corr.coefs$mean),][,1]))
model.corr.coefs$mean <- pmax(model.corr.coefs$mean, 0)

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(model.corr.coefs, aes(x=test, y=mean, group=model, col=as.factor(model.corr.coefs$model))) +
  theme(legend.title = element_blank())+
  geom_point() +
  #guides(fill=guide_legend(title="Model")) +
  xlab("Clinical Laboratory Test") + 
  #ylab(expression(atop("Cross-Validated", paste( "Cor Coef (+/- SD)")))) +
  ylab(expression(atop("Cross-Validated", paste( "Sqrt of % Variance Explained (+/- SD)")))) +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text.y = element_text(hjust = 1)) +
  ylim(0,0.5) +
  scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.5)
  #, position=position_dodge(.7))

write.table(models.corr.coefs, "/Users/jessilyn/Desktop/framework_paper/Figure3/Fig3C/20180504_pct_var_30k_noDemog.csv",row.names=FALSE,col.names=TRUE, sep=",")
#write.table(models.corr.coefs, "../SECURE_data/20180503_pct_var_30k_noDemog.csv",row.names=FALSE,col.names=FALSE, sep=",")

##########################################################
#    Fig 3C + Demographics + BloodPressure + Respiration #
##########################################################
library(caret)
library(plyr)

names(corDf)[names(corDf) %in% "GLU_SerPlas"] <-"GLU"  # fix names to be same between iPOP and 30K datasets ; number of NAs for each GLU: GLU_nonFasting (113472), GLU_wholeBld (111726), GLU_SerPlas (30949), GLU_byMeter (NA = 101012), GLU_fasting (110303)
names(corDf)[names(corDf)  %in% "LDL_Calc"] <-"LDL"  # fix names to be same between iPOP and 30K datasets ; corDf$LDL_Calc range = wear$LDL range
corDf.demog <- merge(thirtyKdemog, corDf, by="ANON_ID")
corDf.demog$Gender <- as.factor(corDf.demog$Gender)
corDf.demog$Ethn <- as.factor(corDf.demog$Ethn)

# make sure you have sufficient # of tests
summaries <- summary(corDf.demog) 
to.remove <-c() 
for (i in 6:dim(summaries)[2]){
  if ( #as.numeric(unlist(strsplit(summaries[7,][i], ":"))[2]) != "NA" &
    as.numeric(unlist(strsplit(summaries[7,][i], ":"))[2]) > (dim(corDf.demog)[1] - .005*dim(corDf.demog)[1])){ #remove anything that is missing X% of our total # of observations 
    print(i)
    to.remove <- c(to.remove, names(summaries[7,][i]))
  }
}
to.remove <- gsub("\\s", "", to.remove)
corDf.demog <- corDf.demog[ , -which(names(corDf.demog) %in% c(to.remove))]

cv.runs <- 50
folds <- createFolds(factor(corDf.demog$Ethn), k = cv.runs, list = FALSE) # break data into (cv.runs) folds with equal proportion of ethnicities in each fold - if it becomes unbalanced sometimes one ethnicity will appear in training and note in test and it breaks the pipeline

#check that your folds work the way you expect
corDf.demog$cv.folds <- folds; # ddply(corDf.demog, 'cv.folds', summarise, prop=sum(Ethn=="White")) # check that this equals table(corDf.tmp$Ethn) / cv.runs

options("scipen"=100, "digits"=4)
models=c(" ~ Pulse", # univariate with pulse only
         " ~ Temp", # univariate with temp only
         " ~ Systolic", # univariate with sys only
         " ~ Diastolic",   # univariate with dias only
         " ~ Respiration", # univariate with resp only
         " ~ Pulse + Temp + Systolic + Diastolic + Respiration", # this is the total possible info we can gain from vitals
         " ~ Age + Gender + Ethn", # this is the total possible info we can gain from demog
         " ~ Pulse + Temp + Systolic + Diastolic + Respiration + Age + Gender + Ethn") # this is the total possible info we can gain from vitals and demog

         # " ~ Systolic + Diastolic + Respiration + Age + Gender + Ethn", # trivariate - this is the info we are losing by not having a wearable that measures these things
         # " ~ Pulse + I(Pulse^2) + Temp + I(Temp^2)
         # + Systolic + I(Systolic^2) + Diastolic + I(Diastolic^2) + Respiration + I(Respiration^2) + Age + Gender + Ethn" ) # this is the total possible info we can gain from vitals

models.corr.coefs <- c()
for (i in 1:cv.runs){ #50 fold cross validation (10% test set; 90% training set)
  print(i)
  corDf.tmp = corDf.demog[corDf.demog$cv.folds==i,]  #remove ANON_ID and Clin_Result_Date & demographics
  # ANON_ID = corDf.tmp$ANON_ID # Remember the list of subjects
  corDf.tmp = corDf.tmp[,-c(1,5)]  #remove ANON_ID and Clin_Result_Date & demographics
  nms = names(subset(corDf.tmp, select=-c(Pulse, Temp, Systolic, Diastolic, Respiration, Age, Gender, Ethn)))
  
  # Do stratified cross-validation per subject
  # split into training and test
  folds <- createFolds(factor(corDf.tmp$Ethn), k = 10, list = FALSE) # break data into (10% training, 90% test) folds with equal proportion of ethnicities in each fold - if it becomes unbalanced sometimes one ethnicity will appear in training and note in test and it breaks the pipeline
  corDf.tmp$test.train <- folds
  
  # subjects = unique(ANON_ID)
  # n = length(subjects) # total num of observations
  # test = sample(n)[1:floor(n*0.1)] # 10% of subjects are held for testing
  # test.subj = subjects[test]
  # test.mask = ANON_ID %in% test.subj
  
  for (nm in nms){ # for each of the 50 clinical lab tests
    print(nm)
    #tmp=0
    corDf2 = data.frame(labtest = corDf.tmp[[nm]], Pulse = corDf.tmp$Pulse, Temp = corDf.tmp$Temp,
                        Systolic = corDf.tmp$Systolic, Diastolic = corDf.tmp$Diastolic, Respiration = corDf.tmp$Respiration,
                        Age = corDf.tmp$Age, Gender = corDf.tmp$Gender, Ethn = corDf.tmp$Ethn, test.train = corDf.tmp$test.train
                         ) # prepare data for LM
    #df <- cbind(corDf2[[i]], corDf2[,c("Pulse", "Temp")])
    corDf2 <- na.omit(corDf2)
    train.data <- corDf2[corDf2$test.train<9,]
    test.data <-corDf2[corDf2$test.train==10,] # training set is ~10% of total set, but not exactly because it is ba;ancing by ethnicities
    t<-as.data.frame(table(train.data$Ethn)) # if there is an ethnicity that has zero entries in the training data
    test.data <- test.data[!(test.data$Ethn %in% as.character(t[t[,2]<1,][,1])),] #remove that ethnicity from the test data
    for (k in 1:length(models)){
      model<-lm(as.formula(paste0("labtest",models[k])),data=train.data)
      m <- summary(model) # quadratic univariate with pulse or temp only
      model.null <- lm(as.formula(paste0("labtest"," ~ 1")),data=train.data)
      # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
      # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
      numTrainObs<-length(train.data$Pulse) # train: the number of each clinical lab test that has corresponding vital signs
      numTestObs<-length(test.data[,1]) # test: the number of each clinical lab test that has corresponding vital signs
      pred=predict(model, newdata=test.data)# prediction on test data set
      pred.null=predict(model.null, newdata=test.data)# prediction on test data set
      #rsq.pred = 1 - (mean( pred - test.data[,1])**2 ) / var( (test.data[,1]) ) # test r.sq
      if (length(pred)<1){next}
      r.pred = cor(pred, test.data[,1], use = "complete.obs") # test r.sq
      rssm <- sum((test.data[,1] - pred)^2)
      rss0 <- sum((test.data[,1]- pred.null)^2)
      sqrt.pct.var <- sqrt(1- (rssm/rss0))
      if ((1- (rssm/rss0)) <0) {sqrt.pct.var <- 0}
      name.rsq <- paste("model.mean.rsq", k, sep = ".")
      models.corr.coefs <- rbind(models.corr.coefs,
                                 c(model = name.rsq, cv.step = i, test = nm, corr.coef = r.pred, sqrt.pct.var = sqrt.pct.var, numTestObs = numTestObs, numTrainObs = numTrainObs))
    }
  }
}


write.table(models.corr.coefs, "/Users/jessilyn/Desktop/framework_paper/Figure3/Fig3C/20180506_model_compare_30k_withDemog.csv",row.names=FALSE,col.names=TRUE, sep=",")

corr.coefs <- as.data.frame(models.corr.coefs)
corr.coefs$cv.step <- as.numeric(as.character(corr.coefs$cv.step))
corr.coefs$corr.coef <- as.numeric(as.character(corr.coefs$corr.coef))
corr.coefs$sqrt.pct.var <- as.numeric(as.character(corr.coefs$sqrt.pct.var))

library(dplyr)
## plot corr coefs or sqrt pct var explained (need to change code to plot second one)
model.corr.coefs <- (corr.coefs %>%
                       group_by(test, model) %>% 
                       summarise_at(vars("sqrt.pct.var"), funs(mean,sd))) # change to summarise_at(vars("sqrt.pct.var") or "corr.coef"
model.corr.coefs$model <- mapvalues(model.corr.coefs$model, from = c("model.mean.rsq.1", "model.mean.rsq.2", "model.mean.rsq.3", "model.mean.rsq.4", "model.mean.rsq.5", "model.mean.rsq.6", "model.mean.rsq.7", "model.mean.rsq.8"), 
                                    to = c("~ Pulse","~ Temp","~ Systolic", "~ Diastolic", "~ Respiration", "~ All Vitals", "~ Demographics", "~ All Vitals + Demographics"))
                                    # to = c("~ Systolic", "~ Diastolic", "~ Respiration", "~ Systolic + Diastolic + Respiration", "~ Pulse + P^2 + Temp + T^2 + Systolic + S^2) + Diastolic + D^2 + Respiration + R^2"))
model.corr.coefs <- na.omit(model.corr.coefs)
model.corr.coefs$test  = factor(model.corr.coefs$test, levels=pull(model.corr.coefs[order(-model.corr.coefs$mean),][,1]))
model.corr.coefs$mean <- pmax(model.corr.coefs$mean, 0)
model.corr.coefs.top.names <- model.corr.coefs[model.corr.coefs$test %in% top.names,]

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(model.corr.coefs.top.names, aes(x=test, y=mean, group=model, col=as.factor(model.corr.coefs.top.names$model))) +
  theme(legend.title = element_blank())+
  geom_point(position=position_dodge(.05)) +
  #guides(fill=guide_legend(title="Model")) +
  xlab("Clinical Laboratory Test") + 
  #ylab(expression(atop("Cross-Validated", paste( "Cor Coef (+/- SD)")))) + # if corr coefs
  ylab(expression(atop("Cross-Validated", paste( "Sqrt of % Variance Explained (+/- SD)")))) + # if sqrt pct var
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text.y = element_text(hjust = 1)) +
  ylim(0,0.5) +
  scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.5, position=position_dodge(.05))


# Delta Corr Coeff between Demographics Only and Vitals + Demographics:
# Which clinical lab models benefit the most by the addition of vital signs?
delta.corr.coef <- model.corr.coefs.top.names[model.corr.coefs.top.names$model %in% "~ All Vitals + Demographics",][,3] - model.corr.coefs.top.names[model.corr.coefs.top.names$model %in% "~ Demographics",][,3]
delta.corr.coef<-cbind(as.data.frame(model.corr.coefs.top.names[model.corr.coefs.top.names$model %in% "~ All Vitals + Demographics",][,1]), delta.corr.coef)
delta.corr.coef$test  = factor(delta.corr.coef$test, levels=delta.corr.coef[order(-delta.corr.coef$mean),][,1])
ggplot(delta.corr.coef, aes(x=test, y=mean))+
  geom_point() +
  theme(legend.title = element_blank())+
  xlab("Clinical Laboratory Test") + 
  #ylab(expression(atop("Delta Cor Coef ", paste( "(~ Vitals + Demog ) - (~ Demog )")))) + # if corr coefs
  ylab(expression(atop("Delta Sqrt % Var Explained ", paste( "(~ Vitals + Demog ) - (~ Demog )")))) + 
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text.y = element_text(hjust = 1))
  #ylim(0,0.5)
  
###############
#   Figure 4B #
###############
source("individual-models-ipop.R") # this script automatically generates plots in "plots" directory

###############
#   Figure 4C #
###############
# run after reading in and cleaning data and running Figure 2D section to get top.names

library(lme4)
weartals_theme = theme_bw() + theme(text = element_text(size=18), panel.border = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))

#corr.coefs <-read.table("../SECURE_data/20180322_ranked_models_test_lm.csv",row.names=1, sep=",")
corr.coefs <-read.table("../SECURE_data/20180403_ranked_models_ipop_lm.csv",row.names=1, sep=",")
top.names<-rownames(corr.coefs) # names of lab tests from either the 30k or the iPOP simple bivariate models
top.names<-top.names[top.names %in% names(wear)] # only keep the lab names that are also present in the iPOP data

## Univariate Mixed-effect: True vs predicted 
# !! Only patients with at least min_visits = 20

min_visits = 20
mm.corr.coefs <- c()
lr.corr.coefs <- c()
id.corr.coefs <- c()
clin.idx <- c()
#for (i in 1:length(top.names)){
for (i in 1:4){
  clin = top.names[i]
  patients = sort(table(corDf[!is.na(corDf[[clin]]),]$ANON_ID))
  labs.vitals.tmp = corDf[corDf$ANON_ID %in% names(patients[patients > min_visits]),]
  labs.vitals.tmp$ANON_ID = factor(labs.vitals.tmp$ANON_ID)
  
  nn = nrow(labs.vitals.tmp)
  smp = sample(nn)
  test = smp[(1+floor(nn*0.9)):nn]
  train = smp[1:floor(nn*0.9)]
  
  frm = paste0(clin," ~ Pulse + Temp + (Pulse + Temp|ANON_ID)")
  print(frm)
  if (nrow(labs.vitals.tmp[train,]) && length(unique(labs.vitals.tmp[train,]$ANON_ID)) > 1){
    clin.idx <-c(clin.idx, clin)
    mm = lmer(frm, data = labs.vitals.tmp[train,])
    cf = coef(mm)
    vit = "Pulse"
    #qq = qplot(cf$ANON_ID[vit], geom="histogram")  + weartals_theme + xlab(paste0(top8[i]," ~ ",vit)) + ylab("count")
    #print(qq) 
    #, vp = viewport(layout.pos.row = matchidx$row,
    #                         layout.pos.col = matchidx$col))
    tt = labs.vitals.tmp[test,clin]
  
    # Evaluate LR model
    frm = paste0(clin," ~ Pulse + Temp")
    m0 = lm(frm, labs.vitals.tmp[train,])
    pp = predict(m0, newdata = labs.vitals.tmp[test,])
    #plot(pp, tt)
    lr.corr.coefs <- c(lr.corr.coefs, cor(pp,tt,use = "na.or.complete")) # corr coef of LR model
    
    # Evaluate MM model
    pp = predict(mm, newdata = labs.vitals.tmp[test,])
    #plot(pp, tt)
    mm.corr.coefs<-c(mm.corr.coefs, cor(pp,tt,use = "na.or.complete")) # corr coef of MM model
    
    # Evaluate LR model with ID
    frm = paste0(clin," ~ ANON_ID")
    m0 = lm(frm, labs.vitals.tmp[train,])
    pp = predict(m0, newdata = labs.vitals.tmp[test,])
    #plot(pp, tt)
    id.corr.coefs <- c(id.corr.coefs, cor(pp,tt,use = "na.or.complete")) # corr coef of LR model only with patient ID
  }
}
indiv.corr.coefs <- cbind(lr.corr.coefs, mm.corr.coefs, id.corr.coefs)
rownames(indiv.corr.coefs) <- clin.idx
write.table(indiv.corr.coefs, "../SECURE_data/20180329_indiv_30k_corr_coeffs.csv",row.names=TRUE,col.names=TRUE, sep=",")
data <-read.table("../SECURE_data/20180330/20180329_indiv_30k_corr_coeffs.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)
d <- melt(data, id.vars="X")
ggplot(d, aes(x=X, y=value, col=variable, shape=variable))+
  geom_point(cex=2.5) + 
  weartals_theme




####################
# Suppl. Figure 1  #
####################
iPOPtopTen <- c( "PLT",
                 "ALKP",
                 "BUN",
                 "MONOAB",
                 "HSCRP",
                 "GLU",
                 "GLOB",
                 "A1C",
                 "WBC",
                 "IGM" )

pList <- list(); j=0  
for (i in iPOPtopTen){
  j=j+1
  call <-paste0("iPOPcorDf$",i)
  df <- cbind(iPOPcorDf[[i]], iPOPcorDf[,c("Pulse", "Temp")])
  df <- na.omit(df)
  #pList[[j]] <- 
  print(ggplot(df, aes(x = df$Pulse, y = df[,1])) +
        geom_point(col="black", pch=19, cex=0.5) +
        stat_smooth(method = "lm", formula = y  ~ x + I(x^2), size = 1.5, col="darkred") +
        theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
        xlab("cHR") + ylab(i)) }
#grid.arrange(pList[[1]],pList[[2]],pList[[3]],pList[[4]],pList[[5]],pList[[6]], ncol=2,top="Main Title")
#####
# iPOP binning plot figures
#####
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()
for (j in clinTopTen){
  iPOPcorDf$bin2<-ntile(iPOPcorDf[[j]], 40)
  # for Temp
  # corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Temp)) +
  # geom_point(stat="identity", fill="darkblue") +
  #   geom_errorbar(aes(ymin=Temp-se, ymax=Temp+se), width=.4) +
  #   xlab(paste(c(j, "bins", sep=" ")))+
  #   scale_y_continuous(limits = c(97,99)) 
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  # For Pulse
  iPOPcorDf2 <- summarySE(iPOPcorDf, measurevar="Pulse", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Pulse)) +
  #  geom_bar(stat="identity", fill="darkred") +
  # geom_errorbar(aes(ymin=Pulse-se, ymax=Pulse+se), width=.2) +
  # xlab(paste(c(j, "bins", sep=" ")))
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  print(paste0(j, ": number of data points in bin = ", sum(iPOPcorDf$bin2 %in% "2")))
  print(ggplot(iPOPcorDf2, aes(x = bin2, y = Pulse)) +
          stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
          theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
          geom_point(col="black") +
          xlab(paste0(c(j ," Bin"))))
  summary.pulse <- summary(lm(iPOPcorDf2$Pulse ~ iPOPcorDf2$bin2 + I(iPOPcorDf2$bin2^2)))
  r.squared[j] <- summary.pulse$adj.r.squared
  # print(ggplot(corDf2, aes(x = bin2, y = Temp)) +
  #         stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkblue") +
  #         geom_point(col="black") +
  #         #ylim(c(96,98.5))+
  #         theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
  #         xlab(paste0(c(j ," Bin"))))
  # summary.Temp <- summary(lm(corDf2$Temp ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # r.squared[j] <- summary.Temp$adj.r.squared
  
}
as.matrix(r.squared)



##################
# Suppl. Fig 2A  #
##################
plot(corDf$Pulse ~ corDf$NEUT, pch='.',
     xlab="Neutrophils", ylab="Pulse", font.lab=2,lwd=2,font=2)
abline(lm(corDf$Pulse ~ corDf$NEUT+ (corDf$NEUT)^2), col="blue",lwd=4)

#############################
#    Suppl. Table 2 and 3   #
#############################
# allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
#              "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
#              "CR","EOS","EOSAB","ESR", "GLOB","GLU_byMeter",
#              "GLU_fasting","GLU_nonFasting","GLU_SerPlas",
#              "GLU_wholeBld","HCT","HDL",
#              "HGB","HSCRP","IGM","K","LDL_Calc", "LDL_Direct","LDLHDL","LYM","LYMAB",
#              "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
#              "NEUTAB","NHDL","PLT","PROCALCITONIN", "RBC","RDW","TBIL","TGL","TP","TroponinI","WBC")# RUN 30K CORRELATIONS 
allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EOS","EOSAB","ESR", "GLOB",
             "GLU_fasting","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL_Direct","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT","RBC","RDW","TBIL","TGL","TP","WBC")# RUN 30K CORRELATIONS

# for each lab run a multiple regression:
r<-c()
p<-c()
fstat <-c()
degfree <- c()
tot= 0 
for (i in allClin){
  call <-paste0("corDf$",i)
  df <- cbind(corDf[[i]], corDf[,c("Pulse", "Temp")])
  df <- na.omit(df)
  #tot = tot + length(df$Pulse)
  print(c(i , length(df$Pulse))) # the number of each clinical lab test that has corresponding vital signs
  m <- summary(lm(df[,1] ~ df$Pulse + df$Temp)) # bivariate with pulse + temp
  #m <- summary(lm(df[,1] ~ df$Pulse)) # univariate with pulse or temp only
  #m <- summary(lm(df[,1] ~ df$Temp + I(df$Temp^2))) # quadratic univariate with pulse or temp only
  r[i]<-m$adj.r.squared 
  fstat[i]<-m$fstatistic
  p[i]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3])
  degfree[i]<-m$df
}

options("scipen"=100, "digits"=4)
str(data.frame(as.list(r)))
str(data.frame(as.list(p))); p<-sort(p) 
str(data.frame(as.list(fstat)))
tot # total number of labs that have clin vitals measures corresponding to it

# num lab tests in iPOP dataset
tot <- 0; for (i in 7:56){
  tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot 

# num vital signs in iPOP dataset
tot <- 0; for (i in 7:56){tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot




##############
#  Figure 2B #
##############
# make boxplots for the top best correlated clinic values with vital signs in the 30k cohort

#topHits <- c("GLU_fasting","HSCRP","ESR", "NEUT","RDW","LYM", "ALB", "PROCALCITONIN")
#topHits <- c("HSCRP","NEUTAB","NEUT","LYM", "PLT", "TroponinI", "ESR", "PROCALCITONIN")

for (i in clinTopTen){
  #quartile
  #below<-corDf$Temp[corDf[i] < summary(corDf[i])[5]]
  #above<-corDf$Temp[corDf[i] > summary(corDf[i])[5]]
  #decile
  below<- corDf$Temp[sapply(ntile(corDf[i], 40) <= 1, isTRUE)]
  #fifth<- corDf$Temp[ntile(corDf[i], 40) <= 6 & ntile(corDf[i], 40) >= 4 & !is.na(ntile(corDf[i], 40))]
  #tenth<- corDf$Temp[ntile(corDf[i], 40) <= 11 & ntile(corDf[i], 40) >= 9 & !is.na(ntile(corDf[i], 40))]
  above<- corDf$Temp[sapply(ntile(corDf[i], 40) >= 40, isTRUE)]
  print(paste0(i, ": number in upper is ", length(below), " and number of lower is ", length(above)))
  pval<-round(unlist(t.test(below, above)[3]), digits=3)
  #boxplot(below,above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 3rd Quartile","Above 3rd Quartile"), ylab="Temp")
  #boxplot(below,fifth, tenth, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","fifth ventile", "tenth ventile","Above 10th ventile"), ylab="Temp")
  boxplot(below, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Lowest","Highest"), ylab="Temp", col="lavenderblush4")
  #color for skin temp is lavenderblush4
}

# check diabetes ones:
for (i in topHits){
  normal<- corDf$Temp[corDf$GLU_fasting < 100]
  prediabetes<- corDf$Temp[corDf$GLU_fasting > 100 & corDf$GLU_fasting < 110]
  diabetes<- corDf$Temp[ntile(corDf[i], 40) <= 11 & ntile(corDf[i], 40) >= 9 & !is.na(ntile(corDf[i], 40))]
  print(paste0(i, ": number in upper is ", length(below), " and number of lower is ", length(above)))
  pval<-round(unlist(t.test(below, above)[3]), digits=3)
  #boxplot(below,above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 3rd Quartile","Above 3rd Quartile"), ylab="Temp")
  #boxplot(below,fifth, tenth, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","fifth ventile", "tenth ventile","Above 10th ventile"), ylab="Temp")
  boxplot(below, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","Above 10th ventile"), ylab="Temp")
}



############
# Figure 4 #
############
library(lme4)
topNeut <- names(head(sort(pulse.num.top.quartile, decreasing = TRUE), 20)) #the 20 people that had the most measurements of NEUT (between 67 and 171 measurements)
p1 <- ggplot(data = corDf[corDf$ANON_ID %in% topNeut,], aes(x = NEUT, y = Temp, colour = ANON_ID)) +       
  #geom_point() + 
  #geom_smooth(method='lm',formula=y~x, se = FALSE)
  geom_smooth(method='loess',formula=y~x, se = FALSE)
#  geom_smooth(method = "lm", formula = y ~ splines::bs(x, 2), se = FALSE)
model <- lmList(NEUT ~ Temp | ANON_ID, data=corDf)

na.omit(corDf) %>% 
  group_by(ANON_ID) %>% 
  do({
    mod = lm(NEUT ~ Temp, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2])
  })



#########################
# Supplementary Table 1 #
#########################
# get mean +/- SE for each of the 50 clin values
library("psych")
thirtyk.summary <- describe(corDf)

# get p-values and rsquared of univariate correlations
vitalVars <- which(names(corDf) %in% c("Pulse","Temp"))
results <- corr.test(corDf[,3:56],
                     corDf[,c(vitalVars)],
                     method="pearson",adjust="fdr")
#### CREATE DATA FRAME(S) SUMMARIZING RESULTS ####
rCols <- paste0(dimnames(results$r)[[2]],"_R")
pCols <- paste0(dimnames(results$p)[[2]],"_P")
nCols <- paste0(dimnames(results$n)[[2]],"_N")
allCors_R <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_R) <- dimnames(results$r)[[1]]
for(i in 1:length(rCols)){
  allCors_R[,i] <- results$r[,i]
  names(allCors_R)[i] <- rCols[i]
}

allCors_P <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_P) <- dimnames(results$p)[[1]]
for(i in 1:length(pCols)){
  allCors_P[,i] <- results$p[,i]
  names(allCors_P)[i] <- pCols[i]
}

allCors_N <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_N) <- dimnames(results$n)[[1]]
for(i in 1:length(nCols)){
  allCors_N[,i] <- results$n[,i]
  names(allCors_N)[i] <- nCols[i]
}

allCors <- cbind(allCors_R,allCors_P,allCors_N)

newColOrder <- c("Pulse","Temp")

tmp <- allCors
for(i in 1:length(newColOrder)){
  if(i == 1){
    cache <- grep(newColOrder[i],names(allCors))
    tmp[,c(i:sum(0+3))] <- allCors[,c(cache)]
    names(tmp)[c(i:sum(0+3))] <- c(names(allCors)[c(cache)])
    count <- sum(0+3)
  } else {
    if(i != 1){
      cache <- grep(paste0("^",newColOrder[i]),names(allCors))
      tmp[,c(sum(count+1):sum(count+3))] <- allCors[,c(cache)]
      names(tmp)[c(sum(count+1):sum(count+3))] <- c(names(allCors)[c(cache)])
      count <- sum(count+3)
    }
  }
}

allCors <- tmp
sigCors_Ranked <- allCors

#class(sigCors_Ranked$Pulse_P)
sigCors_Ranked <- sigCors_Ranked[
  which(sigCors_Ranked$Pulse_P < 0.05),]

sigCors_Ranked <- sigCors_Ranked[
  order(abs(sigCors_Ranked$Pulse_R),decreasing = TRUE),]

#### SAVE DATA FRAME(S) SUMMARIZING RESULTS ####

write.csv(allCors,
          "~/Desktop/20170810_allCors_VitalsVsLabs.csv",
          row.names=TRUE)

write.csv(sigCors_Ranked,
          "~/Desktop/20170810_sigCorsRanked_VitalsVsLabs.csv",
          row.names=TRUE)

################################
#  Currently not used in paper #
################################

# RUN iPOP CORRELATIONS between labs and vitals
options("scipen"=100, "digits"=4)
models=c(" ~ Pulse", # univariate with pulse only
         " ~ Temp",   # univariate with temp only
         " ~ Pulse + Temp", # bivariate with pulse + temp
         " ~ Pulse + I(Pulse^2)",
         " ~ Temp + I(Temp^2)" )

for (k in 1:length(models)){
  print(k)
  r<-matrix(ncol = length(unique(iPOPcorDf$iPOP_ID)),nrow = length(allClin),
            dimnames=list(
              c(allClin),
              c(unique(iPOPcorDf$iPOP_ID))))
  rsq.pred <-r; p<-r; fstat <-r; degfree <- r; numObs <-r;
  tmp=0
  for (i in allClin){ # for each of the 50 clinical lab tests
    tmp=tmp+1 # counter for index of allClin
    tmp2=0    # counter for index of iPOP_ID
    for (j in unique(iPOPcorDf$iPOP_ID)){ 
      tmp2=tmp2+1  # counter for index of iPOP_ID
      iPOPcorDf2 <- iPOPcorDf[!(iPOPcorDf$iPOP_ID %in% j),] # leave one person out
      df <- cbind(iPOPcorDf2[[i]], iPOPcorDf2[,c("Pulse", "Temp")])
      df <- na.omit(df)
      model<-lm(as.formula(paste0(i,models[k])),data=iPOPcorDf2)
      m <- summary(model) # quadratic univariate with pulse or temp only
      # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
      # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
      numObs[tmp,tmp2]<-length(df$Pulse) # the number of each clinical lab test that has corresponding vital signs
      iPOPcorDf3 <- iPOPcorDf[(iPOPcorDf$iPOP_ID %in% j),] # test set (the one person that was left out)
      df3 <- cbind(iPOPcorDf3[[i]], iPOPcorDf3[,c("Pulse", "Temp")])
      df3 <- na.omit(df3)
      pred=predict(model, newdata=df3)# prediction on test person
      rsq.pred[tmp,tmp2] = 1 - (mean( (pred - df3[,1])**2 ) / var( (df[,1]) )) # test r.sq
    }
  }
  name.rsq <- paste("model.mean.rsq", k, sep = "")
  assign(name.rsq, data.frame(model = name.rsq, test = allClin, means = rowMeans(rsq.pred), sd =apply(rsq.pred, 1, sd))) 
}

rsq.plot<- as.data.frame(as.list((rbind(model.mean.rsq1, model.mean.rsq2, model.mean.rsq3, model.mean.rsq4, model.mean.rsq5))))
rsq.plot$model <- mapvalues(rsq.plot$model, from = c("model.mean.rsq1", "model.mean.rsq2", "model.mean.rsq3", "model.mean.rsq4", "model.mean.rsq5"), to = c("~ Pulse", "~ Temp", "~ Pulse + Temp", " ~ Pulse + I(Pulse^2)", " ~ Temp + I(Temp^2)"))

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(rsq.plot, aes(x=test, y=means, group=model, col=as.factor(rsq.plot$model))) +
  geom_point() +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1)) +
  xlab("Clinical Laboratory Test") + ylab("Cross-Validated R-squared (+/- SD)") +
  labs(linetype='Model')
guides(guide_legend(title="Model"))
#guides(fill=guide_legend(title="Model"))
scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=means-sd, ymax=means+sd), width=0.7,
                position=position_dodge(.7)) + ylim(0,1.5)

tot # total number of labs that have clin vitals measures corresponding to it
# num lab tests in iPOP dataset
tot <- 0; for (i in 7:56){
  tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot 

# num vital signs in iPOP dataset
tot <- 0; for (i in 7:56){tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot



#### END ####


