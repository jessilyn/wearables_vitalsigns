
# Framework Paper Figures
# built from 20170905_thirtyk.R

#### OUTPUT: Figures for paper

#### LIBRARY DEPENDENCIES:
library(ggplot2)
library(data.table)
library(psych)
#library(lme4)
library(nlme)
library(MuMIn)
library(Rmisc)
library(gridExtra)
library(grid)
library(dplyr)
library(MASS)
library("ggthemes")
library(reshape2)
library(randomForest)
library("glmnet")

# FUNCTIONS
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

# Path to the directory with data
dir = "../SECURE_data/"

###################
#### READ DATA ####
###################
#iPOP wearables/clinical combined data
wear <- read.csv(paste0(dir, "Basis2016_Cleaned_NotNorm0824_WeekPrior.csv"),
                 header=TRUE,sep=',',stringsAsFactors=FALSE) # for Lukasz script
# wear <- read.csv("/Users/jessilyn/Documents/Career_Development/Mentoring/RyanRunge/20170803_FINAL_LASSOS/Basis2016_Norm0824_WeekPrior.csv",
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for other figures, may need to resurrect this one

# iPOP vitals (called vitals in Lukasz script)
iPOPvitals <- read.csv(paste0(dir, "vitals.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP Labs (called labs in Lukasz script)
iPOPlabs <- read.csv(
  paste0(dir, "lab_results_20170717.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

# 30k vitals
vitals <- fread(paste0(dir, "all_vitals.csv"),
                header=TRUE,sep=',',stringsAsFactors=FALSE)
vitals <- data.frame(vitals)
# 30k labs
labs <- fread(paste0(dir, "all_labs.csv"),
              header=TRUE,sep=',',stringsAsFactors=FALSE)
# 30K labs/vitals combined file <- generated by 20170908_thirtyk.R
corDf <- read.csv(paste0(dir, "20170905_Cleaned_joined_30k_labs_vitals.csv"),
                   header=TRUE,sep=',',stringsAsFactors=FALSE)

###################
### CLEAN DATA ####
###################

### clean iPOP Vitals ###
names(iPOPvitals)[which(names(iPOPvitals)=="HIMCID")] <- "iPOP_ID"
names(iPOPvitals)[which(names(iPOPvitals)=="RECORDED_TIME")] <- "Clin_Result_Date"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Pulse.")] <- "Pulse"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Temp.")] <- "Temp"
names(iPOPvitals)[which(names(iPOPvitals)=="X.BP.")] <- "BP"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Bmi.")] <- "BMI"

for (i in 1:length(iPOPvitals$BP)){
  iPOPvitals$systolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][1]
  iPOPvitals$diastolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][2]
}

#Reformat dates
iPOPvitals$Clin_Result_Date <- format(
  as.Date(iPOPvitals$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

#Make correlation variables numeric
iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")] <- apply(
  iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")], 2,
  function(x) as.numeric(as.character(x)))

#### CLEAN iPOP LABS DATA ####

#Rename columns
names(iPOPlabs)[which(names(iPOPlabs)=="HIMC_ID")] <- "iPOP_ID"
names(iPOPlabs)[which(names(iPOPlabs)=="RESULT_TIME")] <- "Clin_Result_Date"

#Reformat dates
iPOPlabs$Clin_Result_Date <- format(
  as.Date(iPOPlabs$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

allClin <- c("A1C","AG","ALB","ALCRU","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EGFR","EOS","EOSAB","ESR", "GLOB","GLU","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT", "RBC","RDW","TBIL","TGL","TP","UALB","UALBCR","WBC")

for(i in 1:length(allClin)){ #this removes non-numeric characters
  cache <- iPOPlabs[,c(allClin[i])]
  cache <- gsub("[^0-9.]","",cache) #this keeps decimals
  iPOPlabs[,c(allClin[i])] <- cache
}
#Make correlation variables numeric
iPOPlabs[,c(allClin)] <- apply(
  iPOPlabs[,c(allClin)], 2,
  function(x) as.numeric(as.character(x)))

#subset by allClin
iPOPlabs <- iPOPlabs[names(iPOPlabs) %in% c("iPOP_ID","Clin_Result_Date",allClin)]

#Merge data
iPOPcorDf <- merge(iPOPlabs,
                   iPOPvitals[,c("iPOP_ID","Clin_Result_Date",
                                 "Pulse","Temp","BMI","systolic","diastolic")],
                   by=c("iPOP_ID","Clin_Result_Date"))

### clean iPOPcorDf ###
iPOPcorDf[, -c(1,2)] <- apply(iPOPcorDf[, -c(1,2)], 2, remove_outliers)

### clean corDf ### 
corDf[, -c(1,2)] <- apply(corDf[, -c(1,2)], 2, remove_outliers) 



####################
#### Figure 1  #####
####################
iPOPdaysMonitored <- read.csv("/Users/jessilyn/Desktop/framework_paper/Figure1/Slide 2/slide2_C_participant_data_summary.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

###############################
# Fig 1B, left, middle, right #
###############################
hist(iPOPdaysMonitored$Days_monitored_by_clinic, col="grey", breaks=20,
     xlab = "Time Monitored by Clinic (Days)", main = NULL, font.lab=2,lwd=2,font=2)
hist(iPOPdaysMonitored$Days_monitored_by_basis, col="grey", breaks=20,
     xlab = "Time Monitored by Watch (Days)", main = NULL, font.lab=2,lwd=2,font=2)
hist(iPOPdaysMonitored$Total_NumOfClinMeasures, col="grey", breaks=10,
     xlab = "Number of Clinic Visits / Person", main = NULL, font.lab=2,lwd=2,font=2)
mean(iPOPdaysMonitored$Total_NumOfClinMeasures)
mean(iPOPdaysMonitored$Days_monitored_by_clinic)

###############
# Fig 1C, top #
###############

hist(iPOPvitals$Pulse, col="darkred", breaks=50,
     xlab = "cHR", xlim=c(50,200),
     main = NULL, font.lab=2,lwd=2,font=2)
length(iPOPvitals$Pulse[!is.na(iPOPvitals$Pulse)]) # number of cHR measurements in iPOP cohort

hist(iPOPvitals$Temp, col="darkgrey", breaks=50,
     xlab = "cTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)
length(iPOPvitals$Temp[!is.na(iPOPvitals$Temp)]) # number of cTemp measurements in iPOP cohort

################################################
#  Figure 1C Bottom - see Ryans_Figure1_Code.R #
################################################
dfFigOneC <- fread(paste0("/Users/jessilyn/Desktop/framework_paper/Figure1/Fig1C/Ryans_input_files/BasisData_20161111_PostSummerAddOns_Cleaned_NotNormalized_20170928.csv"),
            header=TRUE,sep=",",stringsAsFactors = FALSE)
hist(dfFigOneC$Heart_Rate, col="darkred", breaks=100,
     xlab = "wHR",
     main = NULL, font.lab=2,lwd=2,font=2)

hist(dfFigOneC$Skin_Temperature_F, col="darkgrey", breaks=100,
     xlab = "wTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)

#characterize the iPOP data set
length(na.omit(iPOPvitals$Temp)) + length(na.omit(iPOPvitals$Pulse)) # total number of clinical vital signs measured
describe(iPOPlabs[names(iPOPlabs) %in% allClin]) # summary of clinical labs data
length(unique(wear$iPOP_ID)) # num people in iPOP wearables dataset

##########################################
#  Figure 1D  - see Ryans_Figure1_Code.R #
##########################################

#############################
#    Suppl. Table 1A and B  #
#############################

# make table for vitals (Suppl. Table 1A)
#describe(iPOPvitals)

# make table for labs
#describe(iPOPlabs)


###############
#  Figure 2C  #
###############
## TODO: problem removing NAs for x.train and x.test for the multiple model runs (line 267)
# the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 

# old scripts: load-data.R - now embedded at the top of this script
# old scripts: population-30k.R - now embedded below in this script
# population-models.R - trying to migrate this into current script; see line 239 and below

# create ranked list of clinical laboratory tests by the correlation coefficients between observed and predicted values; checked by Jessie on 2017-12-20
# predicted values from simple bivariate models of (lab test ~ pulse + temp) using 30k dataset
# model uses 10% of people as test set in LOO CV

ANON_ID = corDf$ANON_ID # Remember the list of subjects
corDf.tmp = corDf[,-c(1,2)]  #remove ANON_ID and Clin_Result_Date
corDf.tmp <- subset(corDf.tmp, select=-c(ALCRU)) # all values for ALCRU tests are NA
nms = names(subset(corDf.tmp, select=-c(Pulse, Temp)))

# Do cross-validation per subject
subjects = unique(ANON_ID)
n = length(subjects) # total num of observations
test = sample(n)[1:floor(n*0.1)] # 10% of subjects are held for testing
test.subj = subjects[test]
test.mask = ANON_ID %in% test.subj 

## Cross validated correlation
thirtyk.lm= c()
for (nm in nms){
  df = data.frame(labtest = corDf.tmp[[nm]], Pulse = corDf.tmp$Pulse, Temp = corDf.tmp$Temp) # prepare data for LM
  model = lm(labtest ~ Pulse + Temp, data=df[!test.mask,]) # build the model
  pred = predict(model, newdata = df[test.mask,]) # predict
  cor.coef <- cor(pred, corDf.tmp[[nm]][test.mask], use = "complete.obs")
  thirtyk.lm= rbind(thirtyk.lm, c(nm,cor.coef))
}
corr.coefs <- thirtyk.lm[ order(thirtyk.lm[,2], decreasing = TRUE), ]
#write.table(corr.coefs, "../SECURE_data/ranked_models.csv",row.names=FALSE,col.names=FALSE, sep=",")

# Script to compare different models for predicting lab tests from 30k vitals or iPOP wearables data (adapted from population-models.R)
source("ggplot-theme.R") # just to make things look nice

top.names<-as.character(corr.coefs[,1]) # names of lab tests from the 30k simple bivariate models
top.names<-top.names[top.names %in% names(wear)] # only keep the lab names that are also present in the iPOP data
wear.variables <- unlist(read.table("FinalLasso_153WearableFactors.csv", stringsAsFactors = FALSE)) # the table of model features we want to work with

top.names = top.names

# Get the vitals models
ranked = read.csv("../SECURE_data/ranked_models.csv",header = FALSE)
ranked = ranked[ranked$V1 %in% top.names,]
rsq.all = t(as.matrix(ranked$V2))
colnames(rsq.all) = ranked$V1[ranked$V1 %in% top.names]

# LOO
patients = unique(wear$iPOP_ID)

# Build two lists: predicted vs true
val.true = list()
val.pred = list(lm=list(),rf=list())

modes = c("all","lasso")
model.names = c("lm","rf")

for (mode in modes){
  cat("Feature sellection:",mode,"\n")
  # Build models using wearables data
  for (k in 1:length(patients)){
    train <- patients[patients != patients[k]]
    test <- patients[patients == patients[k]]
    ######################
    ## Build random forest and linear models
    # We will predict one by one, let's create a vector of tests
    res.true <- list()
    res.pred = list(lm=list(),rf=list())
    
    cat("Patient",patients[k],"\n") # LOO
    
    for (l in 1:length(top.names)){
      cat("Test",top.names[l],"\n")
      x.train<-wear[ wear$iPOP_ID %in% train, ] # subset input data by training set
      x.train<-x.train[,colnames(x.train) %in% c(top.names[l], wear.names)] # subset input data by lab: only take current lab test of interest
      x.train<- na.omit(x.train) # skip nas and nans ## the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
      predictors <- as.matrix(x.train[,colnames(x.train) %in% wear.names]) # matrix of predictors for model building
      outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
      
      # create test set
      x.test<-wear[ wear$iPOP_ID %in% test, ] # subset input data by testing set
      x.test<-x.test[,colnames(x.test) %in% c(top.names[l], wear.names)] # subset input data by lab: only take current lab test of interest
      x.test<- na.omit(x.test) # skip nas and nans ## SEE ABOVE FOR ISSUE WITH THIS
      res.true[[l]] = as.matrix(x.test[,top.names[l]]) # true values of left out person
      if (!nrow(x.test)){ # if there are no true values for the left out person, record as NAs
        res.true[[l]] = NA # hacky fix to make line 309 defining val.true to work
      }
      if(mode == "all")
        variables.to.use = wear.names
      if(mode == "lasso"){
        # lasso 
        glm.res = cv.glmnet(x=predictors,y=outcome,
                            standardize.response=FALSE,
                            family="gaussian",
                            nlambda=100)
        variables.to.use = rownames(glm.res$glmnet.fit$beta[abs(glm.res$glmnet.fit$beta[,25]) > 1e-10,]) # TODO: this is an arbitrary rule for now
      }
      
      # Random forest
      fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(variables.to.use,collapse=" + "))
      models.wear.rf = randomForest(as.formula(fml),
                                    data = x.train)
                                    #weights = labs.wear$weight) # should come from lasso maybe?
      res.pred[["rf"]][[l]] = predict(models.wear.rf, newdata = x.test) # predict on left out person
      
      # LM  - always throws warnings; not sure why
      models.wear.lm = lm(as.formula(fml),
                          data = x.train)
                          # , weights = labs.wear$weight) # should come from lasso maybe?
      res.pred[["lm"]][[l]] = predict(models.wear.lm, newdata = x.test)
      # if (!nrow(res.pred[["lm"]][[l]])){ # clarify w/ lukasz --> if there are no predictions from error in lm or rf, record pred values as NA
      #   res.pred[["lm"]][[l]] = NA
      #   res.pred[["rf"]][[l]] = NA
      # }
      # Add predictions and true values for the patient k
      
      for (mdl.name in model.names){
        if (l %in% names(val.pred[[mdl.name]]))
          val.pred[[mdl.name]][[l]] = append(val.pred[[mdl.name]][[l]], res.pred[[mdl.name]][[l]])
        else
          val.pred[[mdl.name]][[l]] = res.pred[[mdl.name]][[l]]
      }

      if (l %in% names(val.true))
        val.true[[l]] = append(val.true[[l]], res.true[[l]]) 
      else
        val.true[[l]] = res.true[[l]]
    }
    # ----
  }
  
  # Get correlation coeffs for each model
  for (mdl.name in model.names){
    rsq.wear = c()
    for (l in 1:length(top.names))
      rsq.wear = c(rsq.wear, cor(val.pred[[mdl.name]][[l]], val.true[[l]]))
    names(rsq.wear) = top.names
    rsq.all = rbind(rsq.all, rsq.wear)
    rownames(rsq.all)[nrow(rsq.all)] = paste(mode,mdl.name,sep="-")
  }
}

rownames(rsq.all)[1] = "vitals"
df = data.frame(rsq.all)
#df[df<0] = 0 # clamp correlations to 0
df$name = rownames(rsq.all)

# Plot the correlations
data = melt(df, id = "name")
colnames(data) = c("model","test","r_squared")

png('plots/figure2C.png',width = 1700, height = 600,res=120)
vitals_res = data[data$model == "vitals",]
data$test = factor(data$test, levels = vitals_res$test[order(-vitals_res$r_squared)])
ggplot(data, aes(test,r_squared, color = model)) + geom_point(size = 5, aes(shape=model, color=model)) +
  weartals_theme + 
  scale_shape_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  scale_color_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  labs(x = "Lab tests",y = expression(paste("correlation"))) + ggtitle("Model comparison")
dev.off()


  ### FILL  IN REST OF population-models.R script ###
  
#########################################
#  Figure 2D  - update with new models  #
#########################################

##############
#  Figure 3A #
##############

hist(table(corDf$ANON_ID), col="darkgrey", breaks=1000, xlab = "Number of Clinic Visits",
     main = NULL, font.lab=2,lwd=2,font=2) # dist. of clinic visits in 30k cohort
hist(table(corDf$ANON_ID)[table(corDf$ANON_ID)>50], col="darkgrey", breaks=1000, xlab = "Number of Clinic Visits",
     main = NULL, font.lab=2,lwd=2,font=2) # dist. of clinic visits in 30k cohort
describe(as.matrix(table(corDf$ANON_ID))) # mean & median number visits in 30k cohort
# duration of time monitored in 30K dataset:
maxDate <-as.Date(as.matrix(tapply(corDf$Clin_Result_Date, corDf$ANON_ID, max)))
minDate <- as.Date(tapply(corDf$Clin_Result_Date, corDf$ANON_ID, min))
duration <- as.numeric(maxDate-minDate)
describe(duration) # mean & median number of days of monitoring in 30k cohort
hist(duration[duration > 50], col="darkgrey", breaks=1000, xlab = "Time Period Monitored (Days)",
     main = NULL, font.lab=2,lwd=2,font=2)

#characterize the 30k data set
length(unique(corDf$ANON_ID)) # num people in 30k dataset where both labs and vitals exist
length(unique(labs$ANON_ID)) # num people in 30k dataset
length(na.omit(labs$Clin_Result_Date)) # num lab tests (in the 50 labs we explored) in 30k dataset
as.matrix(table(labs$LAB_NAME)) # number of each clinical lab
length(na.omit(vitals$Temp)) + length(na.omit(vitals$Pulse)) # total number of clinical vital signs measured
#304 people have more than 50 observations per person
length(table(corDf$ANON_ID)[table(corDf$ANON_ID)>50])

##############
#  Figure 3A #
##############
#30 K Univariate Correlation Fit Plots by Lukasz 
vitalVars <- which(names(corDf) %in% c("Pulse","Temp"))
allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EOS","EOSAB","ESR", "GLOB","GLU_byMeter",
             "GLU_fasting","GLU_nonFasting","GLU_SerPlas",
             "GLU_wholeBld","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL_Calc", "LDL_Direct","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT","PROCALCITONIN", "RBC","RDW","TBIL","TGL","TP","TroponinI","WBC")
clinVars <- which(names(corDf) %in% allClin)


#clin subset of the top 10 most predictive models from bivariate analysis:
clinTopTen <- c("GLU_fasting","CR","HSCRP", "NEUTAB","NEUT","LYM", "RDW","ALB","AG", "PLT","PROCALCITONIN", "ESR")
clinTopTen <- c("NA." , "NEUT", "HSCRP", "RBC", "LDLHDL", "ALB", "NHDL", "HGB", "GLU_fasting", "CL")


# boxplots #http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper functions
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()
for (j in clinTopTen){
  corDf$bin2<-ntile(corDf[[j]], 40)
  # for Temp
  # corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Temp)) +
  # geom_point(stat="identity", fill="darkblue") +
  #   geom_errorbar(aes(ymin=Temp-se, ymax=Temp+se), width=.4) +
  #   xlab(paste(c(j, "bins", sep=" ")))+
  #   scale_y_continuous(limits = c(97,99)) 
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  # For Pulse
  corDf2 <- summarySE(corDf, measurevar="Pulse", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Pulse)) +
  #  geom_bar(stat="identity", fill="darkred") +
  # geom_errorbar(aes(ymin=Pulse-se, ymax=Pulse+se), width=.2) +
  # xlab(paste(c(j, "bins", sep=" ")))
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  print(paste0(j, ": number of data points in bin = ", sum(corDf$bin2 %in% "2")))
  print(ggplot(corDf2, aes(x = bin2, y = Pulse)) +
          stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
          theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
          geom_point(col="black") +
          xlab(paste0(c(j ," Bin"))))
  summary.pulse <- summary(lm(corDf2$Pulse ~ corDf2$bin2 + I(corDf2$bin2^2)))
  r.squared[j] <- summary.pulse$adj.r.squared
  # print(ggplot(corDf2, aes(x = bin2, y = Temp)) +
  #         stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkblue") +
  #         geom_point(col="black") +
  #         #ylim(c(96,98.5))+
  #         theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
  #         xlab(paste0(c(j ," Bin"))))
  # summary.Temp <- summary(lm(corDf2$Temp ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # r.squared[j] <- summary.Temp$adj.r.squared
  
}
as.matrix(r.squared)


##############
#  Figure 3B #
##############

hist(corDf$Pulse, col="darkred", breaks=100,
     xlab = "cHR",
     main = NULL, font.lab=2,lwd=2,font=2)

hist(corDf$Temp, col="darkgrey", breaks=100,
     xlab = "cTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)



##########################################
#    Fig 3C; Suppl. Table 2 and 3        #
##########################################
# RUN iPOP CORRELATIONS between labs and vitals

options("scipen"=100, "digits"=4)
models=c(" ~ Pulse", # univariate with pulse only
         " ~ Temp",   # univariate with temp only
         " ~ Pulse + Temp", # bivariate with pulse + temp
         " ~ Pulse + I(Pulse^2)",
         " ~ Temp + I(Temp^2)" )
for (k in 1:length(models)){
  print(k)
  r<-matrix(ncol = length(unique(iPOPcorDf$iPOP_ID)),nrow = length(allClin),
            dimnames=list(
              c(allClin),
              c(unique(iPOPcorDf$iPOP_ID))))
  rsq.pred <-r; p<-r; fstat <-r; degfree <- r; numObs <-r;
  tmp=0
  for (i in allClin){ # for each of the 50 clinical lab tests
    tmp=tmp+1 # counter for index of allClin
    tmp2=0    # counter for index of iPOP_ID
    for (j in unique(iPOPcorDf$iPOP_ID)){ 
      tmp2=tmp2+1  # counter for index of iPOP_ID
      iPOPcorDf2 <- iPOPcorDf[!(iPOPcorDf$iPOP_ID %in% j),] # leave one person out
      df <- cbind(iPOPcorDf2[[i]], iPOPcorDf2[,c("Pulse", "Temp")])
      df <- na.omit(df)
      model<-lm(as.formula(paste0(i,models[k])),data=iPOPcorDf2)
      m <- summary(model) # quadratic univariate with pulse or temp only
      # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
      # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
      numObs[tmp,tmp2]<-length(df$Pulse) # the number of each clinical lab test that has corresponding vital signs
      iPOPcorDf3 <- iPOPcorDf[(iPOPcorDf$iPOP_ID %in% j),] # test set (the one person that was left out)
      df3 <- cbind(iPOPcorDf3[[i]], iPOPcorDf3[,c("Pulse", "Temp")])
      df3 <- na.omit(df3)
      pred=predict(model, newdata=df3)# prediction on test person
      rsq.pred[tmp,tmp2] = 1 - (mean( (pred - df3[,1])**2 ) / var( (df[,1]) )) # test r.sq
    }
  }
  name.rsq <- paste("model.mean.rsq", k, sep = "")
  assign(name.rsq, data.frame(model = name.rsq, test = allClin, means = rowMeans(rsq.pred), sd =apply(rsq.pred, 1, sd))) 
}

rsq.plot<- as.data.frame(as.list((rbind(model.mean.rsq1, model.mean.rsq2, model.mean.rsq3, model.mean.rsq4, model.mean.rsq5))))
rsq.plot$model <- mapvalues(rsq.plot$model, from = c("model.mean.rsq1", "model.mean.rsq2", "model.mean.rsq3", "model.mean.rsq4", "model.mean.rsq5"), to = c("~ Pulse", "~ Temp", "~ Pulse + Temp", " ~ Pulse + I(Pulse^2)", " ~ Temp + I(Temp^2)"))

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(rsq.plot, aes(x=test, y=means, group=model, col=as.factor(rsq.plot$model))) +
  geom_point() +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
  axis.text.x = element_text(angle = 60, hjust = 1)) +
  xlab("Clinical Laboratory Test") + ylab("Cross-Validated R-squared (+/- SD)") +
  labs(linetype='Model')
  guides(guide_legend(title="Model"))
  #guides(fill=guide_legend(title="Model"))
  scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=means-sd, ymax=means+sd), width=0.7,
                position=position_dodge(.7)) + ylim(0,1.5)



tot # total number of labs that have clin vitals measures corresponding to it
# num lab tests in iPOP dataset
tot <- 0; for (i in 7:56){
  tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot 

# num vital signs in iPOP dataset
tot <- 0; for (i in 7:56){tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot

####################
# Suppl. Figure 1  #
####################
iPOPtopTen <- c( "PLT",
                 "ALKP",
                 "BUN",
                 "MONOAB",
                 "HSCRP",
                 "GLU",
                 "GLOB",
                 "A1C",
                 "WBC",
                 "IGM" )

pList <- list(); j=0  
for (i in iPOPtopTen){
  j=j+1
  call <-paste0("iPOPcorDf$",i)
  df <- cbind(iPOPcorDf[[i]], iPOPcorDf[,c("Pulse", "Temp")])
  df <- na.omit(df)
  #pList[[j]] <- 
  print(ggplot(df, aes(x = df$Pulse, y = df[,1])) +
        geom_point(col="black", pch=19, cex=0.5) +
        stat_smooth(method = "lm", formula = y ~ x, size = 1.5, col="darkred") +
        theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
        xlab("cHR") + ylab(i)) }
#grid.arrange(pList[[1]],pList[[2]],pList[[3]],pList[[4]],pList[[5]],pList[[6]], ncol=2,top="Main Title")
#####
# iPOP binning plot figures
#####
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()
for (j in clinTopTen){
  iPOPcorDf$bin2<-ntile(iPOPcorDf[[j]], 40)
  # for Temp
  # corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Temp)) +
  # geom_point(stat="identity", fill="darkblue") +
  #   geom_errorbar(aes(ymin=Temp-se, ymax=Temp+se), width=.4) +
  #   xlab(paste(c(j, "bins", sep=" ")))+
  #   scale_y_continuous(limits = c(97,99)) 
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  # For Pulse
  iPOPcorDf2 <- summarySE(iPOPcorDf, measurevar="Pulse", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Pulse)) +
  #  geom_bar(stat="identity", fill="darkred") +
  # geom_errorbar(aes(ymin=Pulse-se, ymax=Pulse+se), width=.2) +
  # xlab(paste(c(j, "bins", sep=" ")))
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  print(paste0(j, ": number of data points in bin = ", sum(iPOPcorDf$bin2 %in% "2")))
  print(ggplot(iPOPcorDf2, aes(x = bin2, y = Pulse)) +
          stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
          theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
          geom_point(col="black") +
          xlab(paste0(c(j ," Bin"))))
  summary.pulse <- summary(lm(iPOPcorDf2$Pulse ~ iPOPcorDf2$bin2 + I(iPOPcorDf2$bin2^2)))
  r.squared[j] <- summary.pulse$adj.r.squared
  # print(ggplot(corDf2, aes(x = bin2, y = Temp)) +
  #         stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkblue") +
  #         geom_point(col="black") +
  #         #ylim(c(96,98.5))+
  #         theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
  #         xlab(paste0(c(j ," Bin"))))
  # summary.Temp <- summary(lm(corDf2$Temp ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # r.squared[j] <- summary.Temp$adj.r.squared
  
}
as.matrix(r.squared)



##################
# Suppl. Fig 2A  #
##################
plot(corDf$Pulse ~ corDf$NEUT, pch='.',
     xlab="Neutrophils", ylab="Pulse", font.lab=2,lwd=2,font=2)
abline(lm(corDf$Pulse ~ corDf$NEUT+ (corDf$NEUT)^2), col="blue",lwd=4)

#############################
#    Suppl. Table 2 and 3   #
#############################
# allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
#              "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
#              "CR","EOS","EOSAB","ESR", "GLOB","GLU_byMeter",
#              "GLU_fasting","GLU_nonFasting","GLU_SerPlas",
#              "GLU_wholeBld","HCT","HDL",
#              "HGB","HSCRP","IGM","K","LDL_Calc", "LDL_Direct","LDLHDL","LYM","LYMAB",
#              "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
#              "NEUTAB","NHDL","PLT","PROCALCITONIN", "RBC","RDW","TBIL","TGL","TP","TroponinI","WBC")# RUN 30K CORRELATIONS 
allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EOS","EOSAB","ESR", "GLOB",
             "GLU_fasting","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL_Direct","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT","RBC","RDW","TBIL","TGL","TP","WBC")# RUN 30K CORRELATIONS

# for each lab run a multiple regression:
r<-c()
p<-c()
fstat <-c()
degfree <- c()
tot= 0 
for (i in allClin){
  call <-paste0("corDf$",i)
  df <- cbind(corDf[[i]], corDf[,c("Pulse", "Temp")])
  df <- na.omit(df)
  #tot = tot + length(df$Pulse)
  print(c(i , length(df$Pulse))) # the number of each clinical lab test that has corresponding vital signs
  m <- summary(lm(df[,1] ~ df$Pulse + df$Temp)) # bivariate with pulse + temp
  #m <- summary(lm(df[,1] ~ df$Pulse)) # univariate with pulse or temp only
  #m <- summary(lm(df[,1] ~ df$Temp + I(df$Temp^2))) # quadratic univariate with pulse or temp only
  r[i]<-m$adj.r.squared 
  fstat[i]<-m$fstatistic
  p[i]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3])
  degfree[i]<-m$df
}

options("scipen"=100, "digits"=4)
str(data.frame(as.list(r)))
str(data.frame(as.list(p))); p<-sort(p) 
str(data.frame(as.list(fstat)))
tot # total number of labs that have clin vitals measures corresponding to it







##############
#  Figure 2B #
##############
# make boxplots for the top best correlated clinic values with vital signs in the 30k cohort

#topHits <- c("GLU_fasting","HSCRP","ESR", "NEUT","RDW","LYM", "ALB", "PROCALCITONIN")
#topHits <- c("HSCRP","NEUTAB","NEUT","LYM", "PLT", "TroponinI", "ESR", "PROCALCITONIN")

for (i in clinTopTen){
  #quartile
  #below<-corDf$Temp[corDf[i] < summary(corDf[i])[5]]
  #above<-corDf$Temp[corDf[i] > summary(corDf[i])[5]]
  #decile
  below<- corDf$Temp[sapply(ntile(corDf[i], 40) <= 1, isTRUE)]
  #fifth<- corDf$Temp[ntile(corDf[i], 40) <= 6 & ntile(corDf[i], 40) >= 4 & !is.na(ntile(corDf[i], 40))]
  #tenth<- corDf$Temp[ntile(corDf[i], 40) <= 11 & ntile(corDf[i], 40) >= 9 & !is.na(ntile(corDf[i], 40))]
  above<- corDf$Temp[sapply(ntile(corDf[i], 40) >= 40, isTRUE)]
  print(paste0(i, ": number in upper is ", length(below), " and number of lower is ", length(above)))
  pval<-round(unlist(t.test(below, above)[3]), digits=3)
  #boxplot(below,above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 3rd Quartile","Above 3rd Quartile"), ylab="Temp")
  #boxplot(below,fifth, tenth, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","fifth ventile", "tenth ventile","Above 10th ventile"), ylab="Temp")
  boxplot(below, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Lowest","Highest"), ylab="Temp", col="lavenderblush4")
  #color for skin temp is lavenderblush4
}

# check diabetes ones:
for (i in topHits){
  normal<- corDf$Temp[corDf$GLU_fasting < 100]
  prediabetes<- corDf$Temp[corDf$GLU_fasting > 100 & corDf$GLU_fasting < 110]
  diabetes<- corDf$Temp[ntile(corDf[i], 40) <= 11 & ntile(corDf[i], 40) >= 9 & !is.na(ntile(corDf[i], 40))]
  print(paste0(i, ": number in upper is ", length(below), " and number of lower is ", length(above)))
  pval<-round(unlist(t.test(below, above)[3]), digits=3)
  #boxplot(below,above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 3rd Quartile","Above 3rd Quartile"), ylab="Temp")
  #boxplot(below,fifth, tenth, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","fifth ventile", "tenth ventile","Above 10th ventile"), ylab="Temp")
  boxplot(below, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","Above 10th ventile"), ylab="Temp")
}

##############
#  Figure 3A #
##############


#for (i in clinTopTen){
  i <- "NEUT"
  pulse.diff <- c()
  temp.diff <- c()
  pulse.fourth.quartile <- c()
  pulse.num.fourth.quartile <- c()
  pulse.third.quartile <- c()
  pulse.num.third.quartile <- c()
  pulse.second.quartile <- c()
  pulse.num.second.quartile <- c()
  pulse.first.quartile <- c()
  pulse.num.first.quartile <- c()
  temp.fourth.quartile <- c()
  temp.num.fourth.quartile <- c()
  temp.third.quartile <- c()
  temp.num.third.quartile <- c()
  temp.second.quartile <- c()
  temp.num.second.quartile <- c()
  temp.first.quartile <- c()
  temp.num.first.quartile <- c()
  idx=0
  ptm <- proc.time()
  for (j in unique(corDf$ANON_ID)){
    idx=idx+1
    #create personalized quartiles for each person/measurement type; this step takes a very very long time
    person <- corDf[corDf$ANON_ID == j,]
    if (sum(!is.na(person[,i])) >= 4 & sum(!is.na(person$Pulse)) >= 4){
      print(paste0(idx, " : ", j))
    person$bins2 <- ntile(person[,i], 4)
    #get pulse values when the lab measurement for that person is in their lowest or highest quartile
      pulse.fourth.quartile[j] <- mean(person$Pulse[person$bins2 >= 4])
      pulse.num.fourth.quartile[j] <-length(person$Pulse[person$bins2 >= 4 ])
      pulse.third.quartile[j] <- mean(person$Pulse[person$bins2 >= 3  &  person$bins2 < 4 ])
      pulse.num.third.quartile[j] <- length(person$Pulse[person$bins2 >= 3  &  person$bins2 < 4 ])
      pulse.second.quartile[j] <- mean(person$Pulse[person$bins2 >= 2  &  person$bins2 < 3 ])
      pulse.num.second.quartile[j] <- length(person$Pulse[person$bins2 >= 2  &  person$bins2 < 3 ])
      pulse.first.quartile[j] <- mean(person$Pulse[person$bins2 <= 1 ])
      pulse.num.first.quartile[j] <-length(person$Pulse[person$bins2 <= 1 ])
      # make a way to save this for each i
    
    #get temp values when the lab measurement for that person is in their lowest or highest quantile
      temp.fourth.quartile[j] <- mean(person$Temp[person$bins2 >= 4 ])
      temp.num.fourth.quartile[j] <-length(person$Temp[person$bins2 >= 4 ])
      temp.third.quartile[j] <- mean(person$Temp[person$bins2 >= 3  &  person$bins2 < 4 ])
      temp.num.third.quartile[j] <- length(person$Temp[person$bins2 >= 3  &  person$bins2 < 4 ])
      temp.second.quartile[j] <- mean(person$Temp[person$bins2 >= 2  &  person$bins2 < 3 ])
      temp.num.second.quartile[j] <- length(person$Temp[person$bins2 >= 2  &  person$bins2 < 3 ])
      temp.first.quartile[j] <- mean(person$Temp[person$bins2 <= 1 ])
      temp.num.first.quartile[j] <-length(person$Temp[person$bins2 <= 1 ])
      # make a way to save this for each i
      
    }
  }
  proc.time() - ptm

  personalQuartiles<-cbind(as.matrix(pulse.first.quartile), as.matrix(pulse.second.quartile), as.matrix(pulse.third.quartile),as.matrix(pulse.fourth.quartile),
                           as.matrix(temp.first.quartile), as.matrix(temp.second.quartile), as.matrix(temp.third.quartile), as.matrix(temp.fourth.quartile))
  personalQuartiles <- personalQuartiles[(!is.na(personalQuartiles[,2]) & !is.na(personalQuartiles[,5])),] #remove NAs
  #names(personalQuartiles) <- c("pulse.first.quartile", "pulse.second.quartile", "pulse.third.quartile", "pulse.fourth.quartile", "temp.first.quartile", "temp.second.quartile", "temp.third.quartile","temp.fourth.quartile")
  pulse.diff<-as.matrix(personalQuartiles[,4] - personalQuartiles[,1])
  hist(pulse.diff, breaks=100, col="darkred", main=paste0("Mean Pulse (1st - 4th quartile of ",i, " values)"))
  boxplot(pulse.diff, col="darkred", outline=FALSE, main=paste0("Mean Pulse (1st - 4th quartile of ",i, " values)"))
  temp.diff<-as.matrix(personalQuartiles[,8] - personalQuartiles[,5])
  hist(temp.diff, breaks=100, col="darkblue", main=paste0("Mean Temp (1st - 4th quartile of ",i, " values)"))
  boxplot(temp.diff, col="darkblue", outline=FALSE, main=paste0("Mean Temp (1st - 4th quartile of ",i, " values)"))
  
  
# data in play: temp.diff.neut and pulse.diff.neut and temp.diff.lym and pulse.diff.lym
  hist(temp.diff.neut, breaks=100, main="Temperature Difference Between Personalized  4th and 1st Quartile of Neutrophil Levels", xlab="Temperature Difference", ylab="Number of Individuals", border="black", col="darkblue")
  hist(pulse.diff.neut, breaks=100, main="Pulse Difference Between Personalized 4th and 1st Quartile of Neutrophil Levels", xlab="Pulse Difference", ylab="Number of Individuals", border="black", col="darkred")
  hist(temp.diff.lym, breaks=100, main="Temperature Difference Between Personalized 4th and 1st Quartile of Lymphocyte Levels", xlab="Temperature Difference", ylab="Number of Individuals", border="black", col="darkblue")
  hist(pulse.diff.lym, breaks=100, main="Pulse Difference Between Personalized 4th and 1st Quartile of Lymphocyte Levels", xlab="Pulse Difference", ylab="Number of Individuals", border="black", col="darkred")
  
  write.csv(temp.diff.lym, "~/Desktop/tempdifflym.csv")
  write.csv(pulse.diff.lym, "~/Desktop/pulsedifflym.csv")
  
  length(temp.diff.neut[!is.na(temp.diff.neut)])
#  }
#}

############
# Figure 4 #
############
library(lme4)
topNeut <- names(head(sort(pulse.num.top.quartile, decreasing = TRUE), 20)) #the 20 people that had the most measurements of NEUT (between 67 and 171 measurements)
p1 <- ggplot(data = corDf[corDf$ANON_ID %in% topNeut,], aes(x = NEUT, y = Temp, colour = ANON_ID)) +       
  #geom_point() + 
  #geom_smooth(method='lm',formula=y~x, se = FALSE)
  geom_smooth(method='loess',formula=y~x, se = FALSE)
#  geom_smooth(method = "lm", formula = y ~ splines::bs(x, 2), se = FALSE)
model <- lmList(NEUT ~ Temp | ANON_ID, data=corDf)

na.omit(corDf) %>% 
  group_by(ANON_ID) %>% 
  do({
    mod = lm(NEUT ~ Temp, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2])
  })



#########################
# Supplementary Table 1 #
#########################
# get mean +/- SE for each of the 50 clin values
library("psych")
thirtyk.summary <- describe(corDf)

# get p-values and rsquared of univariate correlations
vitalVars <- which(names(corDf) %in% c("Pulse","Temp"))
results <- corr.test(corDf[,3:56],
                     corDf[,c(vitalVars)],
                     method="pearson",adjust="fdr")
#### CREATE DATA FRAME(S) SUMMARIZING RESULTS ####
rCols <- paste0(dimnames(results$r)[[2]],"_R")
pCols <- paste0(dimnames(results$p)[[2]],"_P")
nCols <- paste0(dimnames(results$n)[[2]],"_N")
allCors_R <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_R) <- dimnames(results$r)[[1]]
for(i in 1:length(rCols)){
  allCors_R[,i] <- results$r[,i]
  names(allCors_R)[i] <- rCols[i]
}

allCors_P <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_P) <- dimnames(results$p)[[1]]
for(i in 1:length(pCols)){
  allCors_P[,i] <- results$p[,i]
  names(allCors_P)[i] <- pCols[i]
}

allCors_N <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_N) <- dimnames(results$n)[[1]]
for(i in 1:length(nCols)){
  allCors_N[,i] <- results$n[,i]
  names(allCors_N)[i] <- nCols[i]
}

allCors <- cbind(allCors_R,allCors_P,allCors_N)

newColOrder <- c("Pulse","Temp")

tmp <- allCors
for(i in 1:length(newColOrder)){
  if(i == 1){
    cache <- grep(newColOrder[i],names(allCors))
    tmp[,c(i:sum(0+3))] <- allCors[,c(cache)]
    names(tmp)[c(i:sum(0+3))] <- c(names(allCors)[c(cache)])
    count <- sum(0+3)
  } else {
    if(i != 1){
      cache <- grep(paste0("^",newColOrder[i]),names(allCors))
      tmp[,c(sum(count+1):sum(count+3))] <- allCors[,c(cache)]
      names(tmp)[c(sum(count+1):sum(count+3))] <- c(names(allCors)[c(cache)])
      count <- sum(count+3)
    }
  }
}

allCors <- tmp
sigCors_Ranked <- allCors

#class(sigCors_Ranked$Pulse_P)
sigCors_Ranked <- sigCors_Ranked[
  which(sigCors_Ranked$Pulse_P < 0.05),]

sigCors_Ranked <- sigCors_Ranked[
  order(abs(sigCors_Ranked$Pulse_R),decreasing = TRUE),]

#### SAVE DATA FRAME(S) SUMMARIZING RESULTS ####

write.csv(allCors,
          "~/Desktop/20170810_allCors_VitalsVsLabs.csv",
          row.names=TRUE)

write.csv(sigCors_Ranked,
          "~/Desktop/20170810_sigCorsRanked_VitalsVsLabs.csv",
          row.names=TRUE)

#### END ####


