
# Framework Paper Figures
# built from 20170905_thirtyk.R

#### OUTPUT: Figures for paper

#### LIBRARY DEPENDENCIES:
library(ggplot2)
library(data.table)
library(psych)
library(nlme)
library(MuMIn)
library(Rmisc)
library(gridExtra)
library(grid)
library(dplyr)
library(MASS)
library("ggthemes")
library(reshape2)
library(randomForest)
library("glmnet")

if(!dir.exists("plots")) dir.create("plots")

# FUNCTIONS
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

# Path to the directory with data
dir = "../SECURE_data/"

###################
#### READ DATA ####
###################

#iPOP wearables/clinical combined data
# wear <- read.csv(paste0(dir, "Basis2016_Cleaned_NotNorm0824_WeekPrior.csv"),
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for Lukasz script
# do not use:  wear <- read.csv("/Users/jessilyn/Documents/Career_Development/Mentoring/RyanRunge/20170803_FINAL_LASSOS/Basis2016_Norm0824_WeekPrior.csv",
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for other figures, may need to resurrect this one
timespans <-c("AllData",
              "MonthPrior",
              "2WeekPrior",
              "WeekPrior",
              "5DayPrior",
              "3DayPrior",
              "DayPrior" )

wear <- read.csv(paste0("/Users/jessilyn/Desktop/framework_paper/Ryan_Runge_Framework_Paper_All_Materials/Output_Tables_from_All_Lassos/Basis_Timespan_Subset_Tables_for_Lassos/", 
                "Basis2016_Clean_Norm_", timespans[7], "_20171020.csv"),
                 header=TRUE,sep=',',stringsAsFactors=FALSE)

# iPOP vitals (called vitals in Lukasz script)
setwd("/Users/jessilyn/Desktop/framework_paper/weartals")
iPOPvitals <- read.csv(paste0(dir, "vitals.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP Labs (called labs in Lukasz script)
iPOPlabs <- read.csv(
  paste0(dir, "lab_results_20170717.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

# 30k vitals
vitals <- fread(paste0(dir, "all_vitals.csv"),
                header=TRUE,sep=',',stringsAsFactors=FALSE)
vitals <- data.frame(vitals)
# 30k labs
labs <- fread(paste0(dir, "all_labs.csv"),
              header=TRUE,sep=',',stringsAsFactors=FALSE)
# 30K labs/vitals combined file <- generated by 20170908_thirtyk.R or 20180412_thirtyk.R (where new vitals like BP and respiration are added in)
# corDf <- read.csv(paste0(dir, "20170905_Cleaned_joined_30k_labs_vitals.csv"),
#                    header=TRUE,sep=',',stringsAsFactors=FALSE)
corDf <- read.csv(paste0(dir, "20180412_Cleaned_joined_30k_labs_ALLvitals.csv"),
                   header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP demographics
iPOPdemographics <- read.csv(paste0(dir, "SECURE_ClinWearDemo_SamplePop.csv"),
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

#thirtyK demographics
thirtyKdemog <- read.csv(paste0(dir, "SECURE_20180412_thirtyKDemog.csv"),
         header=TRUE,sep=',',stringsAsFactors=FALSE)

###################
### CLEAN DATA ####
###################

### clean iPOP Vitals ###
names(iPOPvitals)[which(names(iPOPvitals)=="HIMCID")] <- "iPOP_ID"
names(iPOPvitals)[which(names(iPOPvitals)=="RECORDED_TIME")] <- "Clin_Result_Date"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Pulse.")] <- "Pulse"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Temp.")] <- "Temp"
names(iPOPvitals)[which(names(iPOPvitals)=="X.BP.")] <- "BP"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Bmi.")] <- "BMI"

for (i in 1:length(iPOPvitals$BP)){
  iPOPvitals$systolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][1]
  iPOPvitals$diastolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][2]
}

#Reformat dates
iPOPvitals$Clin_Result_Date <- format(
  as.Date(iPOPvitals$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

#Make correlation variables numeric
iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")] <- apply(
  iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")], 2,
  function(x) as.numeric(as.character(x)))

#### CLEAN iPOP LABS DATA ####

#Rename columns
names(iPOPlabs)[which(names(iPOPlabs)=="HIMC_ID")] <- "iPOP_ID"
names(iPOPlabs)[which(names(iPOPlabs)=="RESULT_TIME")] <- "Clin_Result_Date"

#Reformat dates
iPOPlabs$Clin_Result_Date <- format(
  as.Date(iPOPlabs$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

# allClin <- c("A1C","AG","ALB","ALCRU","ALKP","ALT","AST","BASO",
#              "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
#              "CR","EGFR","EOS","EOSAB","ESR","GLOB","GLU","HCT","HDL",
#              "HGB","HSCRP","IGM","K","LDL","LDLHDL","LYM","LYMAB",
#              "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
#              "NEUTAB","NHDL","PLT", "RBC","RDW","TBIL","TGL","TP","UALB","UALBCR","WBC") 

allClin <- c("ALKP", "LYM", "HSCRP", "ALT", "NEUT", "TBIL", "IGM", "TGL", "MCV", "MCH", "CO2", "LYMAB", "NEUTAB", "UALB", "CHOL", "MONOAB", "ALB", "NA.", "HDL", "PLT", "AG", "HGB", "EOS", "CL", "BUN", "GLOB", "CA", "CHOLHDL", "HCT", "BASOAB", "A1C", "GLU", "LDLHDL", "TP", "EOSAB", "K", "NHDL", "RBC", "MONO", "AST", "MCHC", "RDW", "BASO", "LDL")

for(i in 1:length(allClin)){ #this removes non-numeric characters
  cache <- iPOPlabs[,c(allClin[i])]
  cache <- gsub("[^0-9.]","",cache) #this keeps decimals
  iPOPlabs[,c(allClin[i])] <- cache
}
#Make correlation variables numeric
iPOPlabs[,c(allClin)] <- apply(
  iPOPlabs[,c(allClin)], 2,
  function(x) as.numeric(as.character(x)))

#subset by allClin
iPOPlabs <- iPOPlabs[names(iPOPlabs) %in% c("iPOP_ID","Clin_Result_Date",allClin)]

#Merge data
iPOPcorDf <- merge(iPOPlabs,
                   iPOPvitals[,c("iPOP_ID","Clin_Result_Date",
                                 "Pulse","Temp","BMI","systolic","diastolic")],
                   by=c("iPOP_ID","Clin_Result_Date"))

### clean iPOPcorDf ###
iPOPcorDf[, -c(1,2)] <- apply(iPOPcorDf[, -c(1,2)], 2, remove_outliers)

### clean corDf ### 
corDf[, -c(1,2)] <- apply(corDf[, -c(1,2)], 2, remove_outliers) 



####################
#### Figure 1  #####
####################
iPOPdaysMonitored <- read.csv("/Users/jessilyn/Desktop/framework_paper/Figure1/Slide 2/slide2_C_participant_data_summary.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

###############################
# Fig 1B, left, middle, right #
###############################
hist(iPOPdaysMonitored$Days_monitored_by_clinic, col="grey", breaks=20,
     xlab = "Time Monitored by Clinic (Days)", main = NULL, font.lab=2,lwd=2,font=2)
hist(iPOPdaysMonitored$Days_monitored_by_basis, col="grey", breaks=20,
     xlab = "Time Monitored by Watch (Days)", main = NULL, font.lab=2,lwd=2,font=2)
hist(iPOPdaysMonitored$Total_NumOfClinMeasures, col="grey", breaks=10,
     xlab = "Number of Clinic Visits / Person", main = NULL, font.lab=2,lwd=2,font=2)
mean(iPOPdaysMonitored$Total_NumOfClinMeasures)
mean(iPOPdaysMonitored$Days_monitored_by_clinic)

###############
# Fig 1C, top #
###############

hist(iPOPvitals$Pulse, col="darkred", breaks=50,
     xlab = "cHR", xlim=c(50,200),
     main = NULL, font.lab=2,lwd=2,font=2)
length(iPOPvitals$Pulse[!is.na(iPOPvitals$Pulse)]) # number of cHR measurements in iPOP cohort

hist(iPOPvitals$Temp, col="darkgrey", breaks=50,
     xlab = "cTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)
length(iPOPvitals$Temp[!is.na(iPOPvitals$Temp)]) # number of cTemp measurements in iPOP cohort

################################################
#  Figure 1C Bottom - see Ryans_Figure1_Code.R #
################################################
dfFigOneC <- fread(paste0("/Users/jessilyn/Desktop/framework_paper/Figure1/Fig1C/Ryans_input_files/BasisData_20161111_PostSummerAddOns_Cleaned_NotNormalized_20170928.csv"),
            header=TRUE,sep=",",stringsAsFactors = FALSE)
hist(dfFigOneC$Heart_Rate, col="darkred", breaks=100,
     xlab = "wHR",
     main = NULL, font.lab=2,lwd=2,font=2)

hist(dfFigOneC$Skin_Temperature_F, col="darkgrey", breaks=100,
     xlab = "wTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)

#characterize the iPOP data set
length(na.omit(iPOPvitals$Temp)) + length(na.omit(iPOPvitals$Pulse)) # total number of clinical vital signs measured
describe(iPOPlabs[names(iPOPlabs) %in% allClin]) # summary of clinical labs data
length(unique(wear$iPOP_ID)) # num people in iPOP wearables dataset

##########################################
#  Figure 1D  - see Ryans_Figure1_Code.R #
##########################################

#############################
#    Suppl. Table 1A and B  #
#############################

# make table for vitals (Suppl. Table 1A)
#describe(iPOPvitals)

# make table for labs
#describe(iPOPlabs)


###############
#  Figure 2C  #
###############
## TODO: problem removing NAs for x.train and x.test for the multiple model runs (line 267)
# the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 

# old scripts: load-data.R - now embedded at the top of this script
# old scripts: population-30k.R - now embedded below in this script

# create ranked list of clinical laboratory tests by the correlation coefficients between observed and predicted values
# predicted values from simple bivariate models of (lab test ~ pulse + temp) using iPOP dataset
# LOO cross validation at the subject level 
patients = unique(iPOPcorDf$iPOP_ID)
nms = names(subset(iPOPcorDf, select=-c(iPOP_ID, Clin_Result_Date, Pulse, Temp, BMI, systolic, diastolic)))
corr.coefs.ipop.lm <- c() 
p.value <-0
ipop.lm <- c()
iPOPcorDf.demo <- merge(iPOPcorDf, iPOPdemographics[1:4], by="iPOP_ID")
for (nm in nms){
  print(nm)
  for (i in 1:length(patients)){
  print(patients[i])
  train <- iPOPcorDf.demo[!iPOPcorDf.demo$iPOP_ID %in% patients[i],]
  #train <- na.omit(cbind(subset(train, select = c(iPOP_ID, Pulse, Temp)), train[[nm]]))
  train <- na.omit(cbind(subset(train, select = c(iPOP_ID, Pulse, Temp, AgeIn2016, Gender, Ethn)), train[[nm]])) # with demographics
  colnames(train)[7] <- nm
  test <- iPOPcorDf.demo[iPOPcorDf.demo$iPOP_ID %in% patients[i],]
  #test <- na.omit(cbind(subset(test, select = c(iPOP_ID, Pulse, Temp)), test[[nm]])) 
  test <- na.omit(cbind(subset(test, select = c(iPOP_ID, Pulse, Temp, AgeIn2016, Gender, Ethn)), test[[nm]])) # with demographics
  colnames(test)[7] <- nm
  if (length(test[[nm]])>0){
  bivar.lm.model = lm(train[[nm]] ~ Pulse + Temp + AgeIn2016 + Gender + Ethn, data=train) # build the model
  #bivar.lm.model = lm(train[[nm]] ~ Pulse + Temp, data=train) # build the model
  lm.D0<-lm(train[[nm]] ~ 1)
  t<- anova(lm.D0, bivar.lm.model)
  p.value <- as.numeric(t[2,][["Pr(>F)"]])
  bivar.lm.pred = predict(bivar.lm.model, newdata = test) # predict
  bivar.lm.cor.coef <- cor(bivar.lm.pred, test[[nm]], use = "complete.obs")
  ipop.lm= rbind(ipop.lm, c(nm,bivar.lm.cor.coef, p.value)) 
  }
  }
}
corr.coefs.ipop.lm <- ipop.lm
corr.coefs.ipop.lm <- na.omit(as.data.frame(corr.coefs.ipop.lm)); corr.coefs.ipop.lm$V2 <- as.numeric(as.character(corr.coefs.ipop.lm$V2)); corr.coefs.ipop.lm$V3 <- as.numeric(as.character(corr.coefs.ipop.lm$V3))
means<-aggregate(corr.coefs.ipop.lm[,2:3], by=list(corr.coefs.ipop.lm$V1), mean, na.action = na.omit)
ci<-aggregate(corr.coefs.ipop.lm$V2, by=list(corr.coefs.ipop.lm$V1), function(x){mean(x)+c(-1.96,1.96)*sd(x)/sqrt(length(x))})
means <- means [order(means[,2] ,decreasing = TRUE),]
colnames(means)<- c("test", "corr.coef", "p.val")
means = means[means$test %in% allClin,]
write.table(means, "../SECURE_data/20180403_ranked_models_ipop_lm_with_demographics.csv",row.names=FALSE,col.names=FALSE, sep=",")

# Script to compare different models for predicting lab tests from iPOP wearables data (adapted from population-models.R)
source("ggplot-theme.R") # just to make things look nice

wear.variables <- unlist(read.table("FinalLasso_153WearableFactors.csv", stringsAsFactors = FALSE)) # the table of model features we want to work with
demo.variables <- c("AgeIn2016", "Gender", "Ethn")
wear$Gender <- as.factor(wear$Gender)
wear$Ethn <- as.factor(wear$Ethn)

# Get the vitals models
#ranked = read.csv("../SECURE_data/20180322_ranked_models_test_lm.csv",header = FALSE)
ranked = read.csv("../SECURE_data/20180403_ranked_models_ipop_lm_with_demographics.csv",header = FALSE)
top.names<-top.names<-c("LYM", "NEUT", "LYMAB", "NEUTAB", "IGM", "HSCRP", "ALKP", "ALT", "HDL", "MCV", "TBIL", "CHOLHDL", "GLOB", "AG", "CO2", "CA", "LDLHDL", "BUN", "NHDL", "NA.", "UALB", "MONOAB", "CHOL", "MONO", "RDW", "HCT", "TP", "TGL", "EOS", "LDL", "GLU", "AST", "PLT", "K", "EOSAB", "BASOAB", "MCH", "ALB", "HGB", "A1C", "CL", "RBC", "BASO", "MCHC") # names of lab tests from the 30k simple bivariate models
top.names<-top.names[top.names %in% names(wear)] # only keep the lab names that are also present in the iPOP data
rsq.all = t(as.matrix(ranked$V2))
colnames(rsq.all) = ranked$V1[ranked$V1 %in% top.names] # Ordering same as corr.coefs <- will change this 

# LOO
patients = unique(wear$iPOP_ID)

modes = c("all","lasso")
model.names = c("lm","rf")
num.Records = list(left.Out=list(),lab.Test=list(), num.Train.Obs=list(), num.Test.Obs=list()) # make sure sufficient number of observations for each test and training set
idx=1 # index for entry into num.Records

# top.names <- top.names[1:5] # for troubleshooting

for (mode in modes){
  # Build two lists: predicted vs true
  val.true = list()
  val.pred = list(lm=list(),rf=list())
  cat("Feature selection:",mode,"\n")
  
  # Build models using wearables data
  #for (k in 1:length(patients)){
  for (k in 1:2){
    train <- patients[patients != patients[k]]
    test <- patients[patients == patients[k]]
    ######################
    ## Build random forest and linear models
    # We will predict one by one, let's create a vector of tests
    res.true <- list()
    res.pred = list(lm=list(),rf=list())
    p.value<-list()
    cat("Patient",patients[k],"\n") # LOO
    

    for (l in 1:length(top.names)){
      print(l)
      cat("Test",top.names[l],"\n")
      x.train<-wear[ wear$iPOP_ID %in% train, ] # subset input data by training set
      x.train<-x.train[,colnames(x.train) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
      x.train<- na.omit(x.train) # skip nas and nans ## TODO: the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
      #predictors <- as.matrix(x.train[,colnames(x.train) %in% wear.variables]) # matrix of predictors for model building
      predictors <- as.data.frame(x.train[,colnames(x.train) %in% c(wear.variables, demo.variables)]) # later add in demographics
      
      outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
      
      # create test set
      x.test<-wear[ wear$iPOP_ID %in% test, ] # subset input data by testing set
      x.test<-x.test[,colnames(x.test) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
      x.test<- na.omit(x.test) # skip nas and nans ## TODO: SEE ABOVE na.omit FOR ISSUE WITH THIS
      res.true[[l]] = as.matrix(x.test[,top.names[l]]) # true values of left out person

      if (!nrow(x.test)){ # if there are no true values for the left out person, record as NAs
        res.true[[l]] = NA # TODO: keep track of number of people this happens to
      }
      if(mode == "all"){
        num.Records[[1]][[idx]] <- patients[k]
        num.Records[[2]][[idx]] <- top.names[l]
        num.Records[[3]][[idx]] <-length(outcome) ## store num training obs
        num.Records[[4]][[idx]] <- length(res.true[[l]]) ## store num test obs
        idx=idx+1 # to index entry into num.Records
        #variables.to.use = wear.variables
        variables.to.use = c(wear.variables, demo.variables) # later, add in demographics
      }
      if(mode == "lasso"){
        # lasso 
        n <- as.numeric(length(outcome)) #optional argument for leave-one-out CV method for nfold

        dem = c("Gender", "Ethn") # do not use demographics for lasso
        glm.res = cv.glmnet(x=as.matrix(predictors[,-which(names(predictors) %in% dem)]),y=outcome,
                            standardize.response=FALSE,
                            family="gaussian",
			                      nfolds=n,
                            nlambda=100)
        variables.to.use = rownames(glm.res$glmnet.fit$beta[abs(glm.res$glmnet.fit$beta[,25]) > 1e-10,]) # TODO: this is an arbitrary rule for now
        variables.to.use = c(dem,variables.to.use) # add back Gender and ethn
      }
      
      # Random forest
      fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(variables.to.use,collapse=" + "))
      set.seed(1)
      models.wear.rf = randomForest(as.formula(fml),
                                    data = x.train)
                                    #weights = labs.wear$weight) # TODO: do we need to include this line?
      res.pred[["rf"]][[l]] = predict(models.wear.rf, newdata = x.test) # predict on left out person
      
      # LM  - always throws warnings; not sure why
      models.wear.lm = lm(as.formula(fml),
                          data = x.train)
                          # , weights = labs.wear$weight) # TODO: do we need to include this line?
      res.pred[["lm"]][[l]] = predict(models.wear.lm, newdata = x.test)
      # create a null model for significance testing
      fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~ 1")
      lm.D0<-lm(as.formula(fml), data=x.train) 
      t<- anova(lm.D0, models.wear.lm)
      p.value[["lm"]][[l]] <- as.numeric(t[2,][["Pr(>F)"]])
      # if (!nrow(res.pred[["lm"]][[l]])){ # clarify w/ lukasz --> if there are no predictions from error in lm or rf, record pred values as NA
      #   res.pred[["lm"]][[l]] = NA
      #   res.pred[["rf"]][[l]] = NA
      # }
      # Add predictions and true values for the patient k

      for (mdl.name in model.names){
        if (l <= length(val.pred[[mdl.name]])) # TODO: I don't understand what the if else statements below are doing
          val.pred[[mdl.name]][[l]] = append(val.pred[[mdl.name]][[l]], res.pred[[mdl.name]][[l]]) #append new predictions to val.pred matrix
        else
          val.pred[[mdl.name]][[l]] = res.pred[[mdl.name]][[l]] # initiate val.pred matrix
      }

      if (l <= length(val.true))
        val.true[[l]] = append(val.true[[l]], res.true[[l]]) 
       else 
        val.true[[l]] = res.true[[l]] # initiate val.true matrix
    }
    # ----
  }
  
  # Get correlation coeffs for each model
  for (mdl.name in model.names){
    rsq.wear = c()
    for (j in 1:length(top.names))
      rsq.wear = c(rsq.wear, cor(val.pred[[mdl.name]][[j]], na.omit(val.true[[j]])))
    names(rsq.wear) = top.names
    rsq.all = rbind(rsq.all, rsq.wear)
    rownames(rsq.all)[nrow(rsq.all)] = paste(mode,mdl.name,sep="-")
    
  }
}

num.Records <- do.call("cbind",num.Records) 
#write.table(num.Records, "../SECURE_data/num_Records_day_prior_with_demographics.csv",row.names=FALSE,col.names=FALSE, sep=",")

rownames(rsq.all)[1] = "vitals"
  df = data.frame(rsq.all)
#df[df<0] = 0 # clamp correlations to 0
df$name = rownames(rsq.all)
#df <- df [order(df[,*make this the RF_all or LM_LASSO*] ,decreasing = TRUE),]

# Plot the correlations
data = melt(df, id = "name")
colnames(data) = c("model","test","r_squared")


#png('SECURE_data/figure2C.png',width = 1700, height = 600,res=120)
vitals_res = data[data$model == "vitals",]
data$test = factor(data$test, levels = vitals_res$test[order(-vitals_res$r_squared)])
ggplot(data, aes(test,r_squared, color = model)) + geom_point(size = 5, aes(shape=model, color=model)) +
  weartals_theme + 
  ylim(0,0.5) +
  scale_shape_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  scale_color_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  labs(x = "Lab tests",y = expression(paste("correlation"))) + ggtitle("Model comparison")
#dev.off()
write.table(data, "../SECURE_data/20180123_corr_coeffs_week_prior.csv",row.names=FALSE,col.names=FALSE, sep=",")

####################################
#   Figure 2C Timecourse / 5 (??)  #
####################################
#Run after running individual time course jobs that produced corr_coeffs and num_Records files   #
weartals_theme = theme_bw() + theme(text = element_text(size=18), panel.border = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))
# read in each of the corr_coeffs from the different time windows
# 20180327_corr_coeffs_AllData.csv , 20180327_corr_coeffs_MonthPrior.csv, 20180327_corr_coeffs_TwoWeekPrior.csv, 20180327_corr_coeffs_WeekPrior.csv,20180327_corr_coeffs_DayPrior.csv, 20180327_corr_coeffs_ThreeDayPrior.csv, 
# save as pdf 4x12.5"
data <-read.table("../SECURE_data/20180330/20180327/20180403_corr_coeffs_AllData.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

#png('SECURE_data/20180330/time_windows_AllData.png',width = 1700, height = 600,res=120)
vitals_res = data[data$model == "vitals.ipop",]
data$test = factor(data$test, levels = vitals_res$test[order(-vitals_res$r_squared)])
data$model = factor(data$model)
data$r_squared <- pmax(data$r_squared, 0)
# model.corr.coefs <- na.omit(model.corr.coefs)
data$test = factor(data$test, levels = data[order(-data$r_squared),][,2])
# model.corr.coefs$test  = factor(model.corr.coefs$test, levels=pull(model.corr.coefs[order(-model.corr.coefs$mean),][,1]))


ggplot(data, aes(test,r_squared, color = model)) + geom_point(size = 5, aes(shape=model, color=model)) +
  weartals_theme + 
  ylim(0,0.5) +
  scale_shape_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  scale_color_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
                       labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
  labs(x = "Lab tests",y = expression(paste("Corr Coeff")))
#dev.off()
# make the case that if we could do the RF etc on all data (dont need to be individualized models) and we could combine the individualized models we could do an awesome job at preciting the clinical labs.
# can we create one more layer of mixed effects models in the iPOP analysis here?

################################################
#  Figure 2E  - Canonical Correlation Analysis #
################################################

# should we make this regularized - what is the right proportion between observations and features to decide this (I think there we have ~2X the numver of obs as features)

# library("devtools)
# install_url("https://cran.r-project.org/src/contrib/Archive/impute/impute_1.26.0.tar.gz")
# install.packages("PMA)

library("PMA")
library("Hmisc")
clinical.groups = list()
clinical.groups[["Electrolytes"]] =c("CA","K","CL","CO2","NA.","AG")
clinical.groups[["Diabetes"]] =c("A1C","ALB","GLU","UALB","CR","ALCRU")
#clinical.groups[["Cardiovascular.Disease"]]=c("CHOL","LDLHDL","HDL","CHOLHDL","NHDL","TGL","LDL")
clinical.groups[["Liver Function"]]=c("ALKP","BUN","ALT","TBIL","AST")
clinical.groups[["Inflammation"]]=c("BASO","LYM","LYMAB","MONO","MONOAB","NEUT","NEUTAB","IGM","EOS","EOSAB","BASOAB","WBC","HSCRP")
clinical.groups[["Blood"]] = c("PLT","GLOB","TP","HGB","HCT","RDW","MCH","MCV","RBC","MCHC")
#clinical.groups[["Cardiometabolic.Disease"]]=c("A1C","ALB","GLU","UALB","CR","ALCRU","CHOL"," LDLHDL","HDL","CHOLHDL","NHDL","TGL","LDL")
cca.corr.coefs <- c()
patients <- unique(wear$iPOP_ID)

#wear$LDL = as.numeric(wear$LDL)

for (nm in names(clinical.groups)){
  print(nm)
  # Remove rows with NAs
  data.clin = wear[,which(colnames(wear) %in% c("iPOP_ID", clinical.groups[[nm]]))]
  data.wear = wear[,which(colnames(wear) %in% wear.variables)]
  d <- cbind(data.clin, data.wear)
  d <- na.omit(d)
  iPOP.idx <- d[,1]
  d<-d[-1]
  # remove correlated columns
  tmp <- cor(d)
  tmp[upper.tri(tmp)] <- 0
  diag(tmp) <- 0
  d <- d[,!apply(tmp,2,function(x) any(x > 0.99999999999))] # how does it choose which variable to get rid of? Does it matter which one bc they are linear combos of eachother?

  d = scale(d,scale = FALSE) # why scale it?
  indexX = c()
  indexY = c()
  
  # leave one person out CV
  for (i in 1:length(patients)){
    train <- d[!iPOP.idx %in% patients[i],,drop=FALSE]
    test <- d[iPOP.idx %in% patients[i],,drop=FALSE]
    if (nrow(test) != 1){ #maybe make this > 0?

  # build the CCA model
  model.cc = CCA(train[,(ncol(data.clin)):(ncol(train))],
                train[,1:(ncol(data.clin)-1)],trace = FALSE,K=1)

  #plug in test data using coefficients from CCA model and compare right and left sides
  indexX = c(indexX, as.matrix(test[,(ncol(data.clin)):(ncol(test))]) %*% model.cc$u)
  indexY = c(indexY, as.matrix(test[,1:(ncol(data.clin)-1)]) %*% model.cc$v)
  
  #cca.corr <- cor(indexX, indexY)
  #print(model.cc$cor[1])
  #cca.corr.coefs <- rbind(cca.corr.coefs, c(nm, model.cc$cor[1], patients[i]))
  #cca.corr.coefs <- rbind(cca.corr.coefs, c(nm, cca.corr, patients[i]))
    }
  }
  cca.corr <- cor(indexX, indexY)
  print(ggplot(data.frame(indexX = indexX, indexY = indexY),aes(indexX,indexY)) +
    weartals_theme +
    geom_point() +
    ggtitle(nm) +
    stat_summary(fun.data=mean_cl_normal) +
    geom_smooth(method='lm',formula=y~x))
  print(cca.corr)
}
# library(dplyr)
# data <- (cca.corr.coefs %>%
#                        group_by(nm) %>% 
#                        summarise_at(vars("cca.corr"), funs(mean,sd)))
ggplot(data, aes(x=nm, y=mean)) +
  theme(legend.title = element_blank()) +
  geom_point() +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1)) +
  #ylim(0,0.5) +
  labs(x = "Physiology Subsets", y ="Correlation Coefficient")
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.5)

##############
#  Figure 3A #
##############

hist(table(corDf$ANON_ID), col="darkgrey", breaks=1000, xlab = "Number of Clinic Visits",
     main = NULL, font.lab=2,lwd=2,font=2) # dist. of clinic visits in 30k cohort
hist(table(corDf$ANON_ID)[table(corDf$ANON_ID)>50], col="darkgrey", breaks=1000, xlab = "Number of Clinic Visits",
     main = NULL, font.lab=2,lwd=2,font=2) # dist. of clinic visits in 30k cohort
describe(as.matrix(table(corDf$ANON_ID))) # mean & median number visits in 30k cohort
# duration of time monitored in 30K dataset:
maxDate <-as.Date(as.matrix(tapply(corDf$Clin_Result_Date, corDf$ANON_ID, max)))
minDate <- as.Date(tapply(corDf$Clin_Result_Date, corDf$ANON_ID, min))
duration <- as.numeric(maxDate-minDate)
describe(duration) # mean & median number of days of monitoring in 30k cohort
hist(duration[duration > 50], col="darkgrey", breaks=1000, xlab = "Time Period Monitored (Days)",
     main = NULL, font.lab=2,lwd=2,font=2)

#characterize the 30k data set
length(unique(corDf$ANON_ID)) # num people in 30k dataset where both labs and vitals exist
length(unique(labs$ANON_ID)) # num people in 30k dataset
length(na.omit(labs$Clin_Result_Date)) # num lab tests (in the 50 labs we explored) in 30k dataset
as.matrix(table(labs$LAB_NAME)) # number of each clinical lab
length(na.omit(vitals$Temp)) + length(na.omit(vitals$Pulse)) # total number of clinical vital signs measured
#304 people have more than 50 observations per person
length(table(corDf$ANON_ID)[table(corDf$ANON_ID)>50])

########################
#  Figure 3A 3D and 3E #
########################
#30 K Univariate Correlation Fit Plots by Lukasz 
vitalVars <- which(names(corDf) %in% c("Pulse","Temp"))
allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EOS","EOSAB","ESR", "GLOB","GLU_byMeter",
             "GLU_fasting","GLU_nonFasting","GLU_SerPlas",
             "GLU_wholeBld","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL_Calc", "LDL_Direct","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT","PROCALCITONIN", "RBC","RDW","TBIL","TGL","TP","TroponinI","WBC")
clinVars <- which(names(corDf) %in% allClin)


#clin subset of the top 10 most predictive models from bivariate analysis:
clinTopTen <- c("GLU_fasting","CR","HSCRP", "NEUTAB","NEUT","LYM", "RDW","ALB","AG", "PLT","PROCALCITONIN", "ESR")
clinTopTen <- c("NA." , "NEUT", "HSCRP", "RBC", "LDLHDL", "ALB", "NHDL", "HGB", "GLU_fasting", "CL")


# boxplots #http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper functions
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()

for (j in clinTopTen){
  corDf$bin2<-ntile(corDf[[j]], 40)
  # for Temp
  # corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Temp)) +
  # geom_point(stat="identity", fill="darkblue") +
  #   geom_errorbar(aes(ymin=Temp-se, ymax=Temp+se), width=.4) +
  #   xlab(paste(c(j, "bins", sep=" ")))+
  #   scale_y_continuous(limits = c(97,99)) 
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  # For Pulse
  corDf2 <- summarySE(corDf, measurevar="Pulse", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Pulse)) +
  #  geom_bar(stat="identity", fill="darkred") +
  # geom_errorbar(aes(ymin=Pulse-se, ymax=Pulse+se), width=.2) +
  # xlab(paste(c(j, "bins", sep=" ")))
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  print(paste0(j, ": number of data points in bin = ", sum(corDf$bin2 %in% "2")))
  #model <-lm(corDf2$Pulse  ~ corDf2$bin2 + I((corDf2$bin2)^2))
  print(ggplot(corDf2, aes(x = bin2, y = Pulse)) +
          stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
          theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
          geom_point(col="black") +
          xlab(paste0(c(j ," Bin"))))
  

  summary.pulse <- summary(lm(corDf2$Pulse ~ corDf2$bin2 + I(corDf2$bin2^2)))
  r.squared[j] <- summary.pulse$adj.r.squared
  # print(ggplot(corDf2, aes(x = bin2, y = Temp)) +
  #         stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkblue") +
  #         geom_point(col="black") +
  #         #ylim(c(96,98.5))+
  #         theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
  #         xlab(paste0(c(j ," Bin"))))
  # summary.Temp <- summary(lm(corDf2$Temp ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # r.squared[j] <- summary.Temp$adj.r.squared
}
as.matrix(r.squared)


##############
#  Figure 3B #
##############

hist(corDf$Pulse, col="darkred", breaks=100,
     xlab = "cHR",
     main = NULL, font.lab=2,lwd=2,font=2)

hist(corDf$Temp, col="darkgrey", breaks=100,
     xlab = "cTemp", xlim=c(65,105),
     main = NULL, font.lab=2,lwd=2,font=2)

#####################
#  Figure 3F and 3G #
#####################


#for (i in clinTopTen){
i <- "NEUT"
pulse.diff <- c()
temp.diff <- c()
pulse.fourth.quartile <- c()
pulse.num.fourth.quartile <- c()
pulse.third.quartile <- c()
pulse.num.third.quartile <- c()
pulse.second.quartile <- c()
pulse.num.second.quartile <- c()
pulse.first.quartile <- c()
pulse.num.first.quartile <- c()
temp.fourth.quartile <- c()
temp.num.fourth.quartile <- c()
temp.third.quartile <- c()
temp.num.third.quartile <- c()
temp.second.quartile <- c()
temp.num.second.quartile <- c()
temp.first.quartile <- c()
temp.num.first.quartile <- c()
idx=0
ptm <- proc.time()
for (j in unique(corDf$ANON_ID)){
  idx=idx+1
  #create personalized quartiles for each person/measurement type; this step takes a very very long time
  person <- corDf[corDf$ANON_ID == j,]
  if (sum(!is.na(person[,i])) >= 4 & sum(!is.na(person$Pulse)) >= 4){
    print(paste0(idx, " : ", j))
    person$bins2 <- ntile(person[,i], 4)
    #get pulse values when the lab measurement for that person is in their lowest or highest quartile
    pulse.fourth.quartile[j] <- mean(person$Pulse[person$bins2 >= 4])
    pulse.num.fourth.quartile[j] <-length(person$Pulse[person$bins2 >= 4 ])
    pulse.third.quartile[j] <- mean(person$Pulse[person$bins2 >= 3  &  person$bins2 < 4 ])
    pulse.num.third.quartile[j] <- length(person$Pulse[person$bins2 >= 3  &  person$bins2 < 4 ])
    pulse.second.quartile[j] <- mean(person$Pulse[person$bins2 >= 2  &  person$bins2 < 3 ])
    pulse.num.second.quartile[j] <- length(person$Pulse[person$bins2 >= 2  &  person$bins2 < 3 ])
    pulse.first.quartile[j] <- mean(person$Pulse[person$bins2 <= 1 ])
    pulse.num.first.quartile[j] <-length(person$Pulse[person$bins2 <= 1 ])
    # make a way to save this for each i
    
    #get temp values when the lab measurement for that person is in their lowest or highest quantile
    temp.fourth.quartile[j] <- mean(person$Temp[person$bins2 >= 4 ])
    temp.num.fourth.quartile[j] <-length(person$Temp[person$bins2 >= 4 ])
    temp.third.quartile[j] <- mean(person$Temp[person$bins2 >= 3  &  person$bins2 < 4 ])
    temp.num.third.quartile[j] <- length(person$Temp[person$bins2 >= 3  &  person$bins2 < 4 ])
    temp.second.quartile[j] <- mean(person$Temp[person$bins2 >= 2  &  person$bins2 < 3 ])
    temp.num.second.quartile[j] <- length(person$Temp[person$bins2 >= 2  &  person$bins2 < 3 ])
    temp.first.quartile[j] <- mean(person$Temp[person$bins2 <= 1 ])
    temp.num.first.quartile[j] <-length(person$Temp[person$bins2 <= 1 ])
    # make a way to save this for each i
    
  }
}
proc.time() - ptm

personalQuartiles<-cbind(as.matrix(pulse.first.quartile), as.matrix(pulse.second.quartile), as.matrix(pulse.third.quartile),as.matrix(pulse.fourth.quartile),
                         as.matrix(temp.first.quartile), as.matrix(temp.second.quartile), as.matrix(temp.third.quartile), as.matrix(temp.fourth.quartile))
personalQuartiles <- personalQuartiles[(!is.na(personalQuartiles[,2]) & !is.na(personalQuartiles[,5])),] #remove NAs
#names(personalQuartiles) <- c("pulse.first.quartile", "pulse.second.quartile", "pulse.third.quartile", "pulse.fourth.quartile", "temp.first.quartile", "temp.second.quartile", "temp.third.quartile","temp.fourth.quartile")
pulse.diff<-as.matrix(personalQuartiles[,4] - personalQuartiles[,1])
hist(pulse.diff, breaks=100, col="darkred", main=paste0("Mean Pulse (1st - 4th quartile of ",i, " values)"))
boxplot(pulse.diff, col="darkred", outline=FALSE, main=paste0("Mean Pulse (1st - 4th quartile of ",i, " values)"))
temp.diff<-as.matrix(personalQuartiles[,8] - personalQuartiles[,5])
hist(temp.diff, breaks=100, col="darkblue", main=paste0("Mean Temp (1st - 4th quartile of ",i, " values)"))
boxplot(temp.diff, col="darkblue", outline=FALSE, main=paste0("Mean Temp (1st - 4th quartile of ",i, " values)"))


# data in play: temp.diff.neut and pulse.diff.neut and temp.diff.lym and pulse.diff.lym
hist(temp.diff.neut, breaks=100, main="Temperature Difference Between Personalized  4th and 1st Quartile of Neutrophil Levels", xlab="Temperature Difference", ylab="Number of Individuals", border="black", col="darkblue")
hist(pulse.diff.neut, breaks=100, main="Pulse Difference Between Personalized 4th and 1st Quartile of Neutrophil Levels", xlab="Pulse Difference", ylab="Number of Individuals", border="black", col="darkred")
hist(temp.diff.lym, breaks=100, main="Temperature Difference Between Personalized 4th and 1st Quartile of Lymphocyte Levels", xlab="Temperature Difference", ylab="Number of Individuals", border="black", col="darkblue")
hist(pulse.diff.lym, breaks=100, main="Pulse Difference Between Personalized 4th and 1st Quartile of Lymphocyte Levels", xlab="Pulse Difference", ylab="Number of Individuals", border="black", col="darkred")

write.csv(temp.diff.lym, "~/Desktop/tempdifflym.csv")
write.csv(pulse.diff.lym, "~/Desktop/pulsedifflym.csv")

length(temp.diff.neut[!is.na(temp.diff.neut)])
#  }
#}

##########################################
#    Fig 3C; Suppl. Table 2 and 3        #
##########################################
# create ranked list of clinical laboratory tests by the correlation coefficients between observed and predicted values; checked by Jessie on 2017-12-20
# predicted values from simple bivariate models of (lab test ~ pulse + temp) using 30k dataset
# Do 10-fold cross validation at the subject level (e.g. each test set contains 1/10 of the people in the 28k dataset)
# RUN 30K CORRELATIONS between labs and vitals

names(corDf)[names(corDf) %in% "GLU_SerPlas"] <-"GLU"  # fix names to be same between iPOP and 30K datasets ; number of NAs for each GLU: GLU_nonFasting (113472), GLU_wholeBld (111726), GLU_SerPlas (30949), GLU_byMeter (NA = 101012), GLU_fasting (110303)
names(corDf)[names(corDf)  %in% "LDL_Calc"] <-"LDL"  # fix names to be same between iPOP and 30K datasets ; corDf$LDL_Calc range = wear$LDL range
options("scipen"=100, "digits"=4)
models=c(" ~ Pulse", # univariate with pulse only
         " ~ Temp",   # univariate with temp only
         " ~ Pulse + Temp", # bivariate with pulse + temp
         " ~ Pulse + I(Pulse^2)",
         " ~ Temp + I(Temp^2)", " ~ Pulse + I(Pulse^2) + Temp + I(Temp^2)" )
cv.runs <- 50
models.corr.coefs <- c()
rsq.pred <- 0
for (i in 1:cv.runs){ #50 fold cross validation (10% test set; 90% training set)
  print(i)
  ANON_ID = corDf$ANON_ID # Remember the list of subjects
  corDf.tmp = corDf[,-c(1,2)]  #remove ANON_ID and Clin_Result_Date
  corDf.tmp <- subset(corDf.tmp, select=-c(ALCRU, CR)) # all values for ALCRU tests are NA, only 20 values for CR are not NA
  nms = names(subset(corDf.tmp, select=-c(Pulse, Temp)))

  # Do cross-validation per subject
  subjects = unique(ANON_ID)
  n = length(subjects) # total num of observations
  test = sample(n)[1:floor(n*0.1)] # 10% of subjects are held for testing
  test.subj = subjects[test]
  test.mask = ANON_ID %in% test.subj

    for (nm in top.names){ # for each of the 50 clinical lab tests
      print(nm)
      tmp=0
      corDf2 = data.frame(labtest = corDf.tmp[[nm]], Pulse = corDf.tmp$Pulse, Temp = corDf.tmp$Temp) # prepare data for LM
      #df <- cbind(corDf2[[i]], corDf2[,c("Pulse", "Temp")])
      corDf2 <- na.omit(corDf2)
      test.data <- na.omit(corDf2[test.mask,])
      train.data <-na.omit(corDf2[!test.mask,])
        for (k in 1:length(models)){
          model<-lm(as.formula(paste0("labtest",models[k])),data=train.data)
          m <- summary(model) # quadratic univariate with pulse or temp only
          # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
          # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
          numObs<-length(train.data$Pulse) # the number of each clinical lab test that has corresponding vital signs
          pred=predict(model, newdata=test.data)# prediction on test data set
          #rsq.pred = 1 - (mean( pred - test.data[,1])**2 ) / var( (test.data[,1]) ) # test r.sq
          r.pred = cor(pred, test.data[,1]) # test r.sq
          name.rsq <- paste("model.mean.rsq", k, sep = ".")
          models.corr.coefs <- rbind(models.corr.coefs,
                                     c(model = name.rsq, cv.step = i, test = nm, corr.coef = r.pred, numObs = numObs))
    }
  }
}

corr.coefs <- as.data.frame(models.corr.coefs)
corr.coefs$cv.step <- as.numeric(as.character(corr.coefs$cv.step))
corr.coefs$corr.coef <- as.numeric(as.character(corr.coefs$corr.coef))

library(dplyr)
model.corr.coefs <- (corr.coefs %>%
  group_by(test, model) %>% 
  summarise_at(vars("corr.coef"), funs(mean,sd)))
model.corr.coefs$model <- mapvalues(model.corr.coefs$model, from = c("model.mean.rsq.1", "model.mean.rsq.2", "model.mean.rsq.3", "model.mean.rsq.4", "model.mean.rsq.5", "model.mean.rsq.6"), to = c("~ Pulse", "~ Temp", "~ Pulse + Temp", " ~ Pulse + P^2", " ~ Temp + T^2", " ~ Pulse + P^2 + Temp + T^2"))
model.corr.coefs <- na.omit(model.corr.coefs)
model.corr.coefs$test  = factor(model.corr.coefs$test, levels=pull(model.corr.coefs[order(-model.corr.coefs$mean),][,1]))
model.corr.coefs$mean <- pmax(model.corr.coefs$mean, 0)

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(model.corr.coefs, aes(x=test, y=mean, group=model, col=as.factor(model.corr.coefs$model))) +
  theme(legend.title = element_blank())+
  geom_point() +
  #guides(fill=guide_legend(title="Model")) +
  xlab("Clinical Laboratory Test") + ylab(expression(atop("Cross-Validated", paste( "Cor Coef (+/- SD)")))) +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text.y = element_text(hjust = 1)) +
  ylim(0,0.5) +
  scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.5)
  #, position=position_dodge(.7))

### Eventually want to include demographics
# thirtyKdemog

###########################################
#    Fig 3C + BloodPressure + Respiration #
###########################################
names(corDf)[names(corDf) %in% "GLU_SerPlas"] <-"GLU"  # fix names to be same between iPOP and 30K datasets ; number of NAs for each GLU: GLU_nonFasting (113472), GLU_wholeBld (111726), GLU_SerPlas (30949), GLU_byMeter (NA = 101012), GLU_fasting (110303)
names(corDf)[names(corDf)  %in% "LDL_Calc"] <-"LDL"  # fix names to be same between iPOP and 30K datasets ; corDf$LDL_Calc range = wear$LDL range
corDf.demog <- merge(thirtyKdemog, corDf, by="ANON_ID")
corDf.demog$Gender <- as.factor(corDf.demog$Gender)
corDf.demog$Ethn <- as.factor(corDf.demog$Ethn)

options("scipen"=100, "digits"=4)
models=c(" ~ Systolic + Age + Gender + Ethn", # univariate with sys only
         " ~ Diastolic + Age + Gender + Ethn",   # univariate with dias only
         " ~ Respiration + Age + Gender + Ethn", # univariate with resp only
         " ~ Systolic + Diastolic + Respiration + Age + Gender + Ethn", # trivariate - this is the info we are losing by not having a wearable that measures these things
         " ~ Pulse + I(Pulse^2) + Temp + I(Temp^2)
         + Systolic + I(Systolic^2) + Diastolic + I(Diastolic^2) + Respiration + I(Respiration^2) + Age + Gender + Ethn" ) # this is the total possible info we can gain from vitals
cv.runs <- 50
models.corr.coefs <- c()
rsq.pred <- 0
for (i in 1:cv.runs){ #50 fold cross validation (10% test set; 90% training set)
  print(i)
  ANON_ID = corDf.demog$ANON_ID # Remember the list of subjects
  corDf.tmp = corDf.demog[,-c(1,5)]  #remove ANON_ID and Clin_Result_Date & demographics
  corDf.tmp <- subset(corDf.tmp, select=-c(ALCRU, CR)) # all values for ALCRU tests are NA, only 20 values for CR are not NA
  nms = names(subset(corDf.tmp, select=-c(Pulse, Temp, Systolic, Diastolic, Respiration, Age, Gender, Ethn)))
  
  # Do cross-validation per subject
  subjects = unique(ANON_ID)
  n = length(subjects) # total num of observations
  test = sample(n)[1:floor(n*0.1)] # 10% of subjects are held for testing
  test.subj = subjects[test]
  test.mask = ANON_ID %in% test.subj
  
  for (nm in top.names){ # for each of the 50 clinical lab tests
    print(nm)
    tmp=0
    corDf2 = data.frame(labtest = corDf.tmp[[nm]], Pulse = corDf.tmp$Pulse, Temp = corDf.tmp$Temp,
                        Systolic = corDf.tmp$Systolic, Diastolic = corDf.tmp$Diastolic, Respiration = corDf.tmp$Respiration,
                        Age = corDf.tmp$Age, Gender = corDf.tmp$Gender, Ethn = corDf.tmp$Ethn
                         ) # prepare data for LM
    #df <- cbind(corDf2[[i]], corDf2[,c("Pulse", "Temp")])
    corDf2 <- na.omit(corDf2)
    test.data <- na.omit(corDf2[test.mask,])
    train.data <-na.omit(corDf2[!test.mask,])
    for (k in 1:length(models)){
      model<-lm(as.formula(paste0("labtest",models[k])),data=train.data)
      m <- summary(model) # quadratic univariate with pulse or temp only
      # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
      # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
      numObs<-length(train.data$Pulse) # the number of each clinical lab test that has corresponding vital signs
      pred=predict(model, newdata=test.data)# prediction on test data set
      #rsq.pred = 1 - (mean( pred - test.data[,1])**2 ) / var( (test.data[,1]) ) # test r.sq
      r.pred = cor(pred, test.data[,1]) # test r.sq
      name.rsq <- paste("model.mean.rsq", k, sep = ".")
      models.corr.coefs <- rbind(models.corr.coefs,
                                 c(model = name.rsq, cv.step = i, test = nm, corr.coef = r.pred, numObs = numObs))
    }
  }
}

corr.coefs <- as.data.frame(models.corr.coefs)
corr.coefs$cv.step <- as.numeric(as.character(corr.coefs$cv.step))
corr.coefs$corr.coef <- as.numeric(as.character(corr.coefs$corr.coef))

library(dplyr)
model.corr.coefs <- (corr.coefs %>%
                       group_by(test, model) %>% 
                       summarise_at(vars("corr.coef"), funs(mean,sd)))
model.corr.coefs$model <- mapvalues(model.corr.coefs$model, from = c("model.mean.rsq.1", "model.mean.rsq.2", "model.mean.rsq.3", "model.mean.rsq.4", "model.mean.rsq.5"), 
                                    to = c("~ Systolic", "~ Diastolic", "~ Respiration", "~ Systolic + Diastolic + Respiration", "~ Pulse + P^2 + Temp + T^2 + Systolic + S^2) + Diastolic + D^2 + Respiration + R^2"))
model.corr.coefs <- na.omit(model.corr.coefs)
model.corr.coefs$test  = factor(model.corr.coefs$test, levels=pull(model.corr.coefs[order(-model.corr.coefs$mean),][,1]))
model.corr.coefs$mean <- pmax(model.corr.coefs$mean, 0)

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(model.corr.coefs, aes(x=test, y=mean, group=model, col=as.factor(model.corr.coefs$model))) +
  theme(legend.title = element_blank())+
  geom_point() +
  #guides(fill=guide_legend(title="Model")) +
  xlab("Clinical Laboratory Test") + ylab(expression(atop("Cross-Validated", paste( "Cor Coef (+/- SD)")))) +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1),
        axis.text.y = element_text(hjust = 1)) +
  ylim(0,0.5) +
  scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=0.5)





###############
#   Figure 4  #
###############
# run after reading in and cleaning data and running Figure 2D section to get top.names

library(lme4)
weartals_theme = theme_bw() + theme(text = element_text(size=18), panel.border = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1))

#corr.coefs <-read.table("../SECURE_data/20180322_ranked_models_test_lm.csv",row.names=1, sep=",")
corr.coefs <-read.table("../SECURE_data/20180403_ranked_models_ipop_lm.csv",row.names=1, sep=",")
top.names<-rownames(corr.coefs) # names of lab tests from either the 30k or the iPOP simple bivariate models
top.names<-top.names[top.names %in% names(wear)] # only keep the lab names that are also present in the iPOP data

## Univariate Mixed-effect: True vs predicted 
# !! Only patients with at least min_visits = 20

min_visits = 20
mm.corr.coefs <- c()
lr.corr.coefs <- c()
id.corr.coefs <- c()
clin.idx <- c()
#for (i in 1:length(top.names)){
for (i in 1:4){
  clin = top.names[i]
  patients = sort(table(corDf[!is.na(corDf[[clin]]),]$ANON_ID))
  labs.vitals.tmp = corDf[corDf$ANON_ID %in% names(patients[patients > min_visits]),]
  labs.vitals.tmp$ANON_ID = factor(labs.vitals.tmp$ANON_ID)
  
  nn = nrow(labs.vitals.tmp)
  smp = sample(nn)
  test = smp[(1+floor(nn*0.9)):nn]
  train = smp[1:floor(nn*0.9)]
  
  frm = paste0(clin," ~ Pulse + Temp + (Pulse + Temp|ANON_ID)")
  print(frm)
  if (nrow(labs.vitals.tmp[train,]) && length(unique(labs.vitals.tmp[train,]$ANON_ID)) > 1){
    clin.idx <-c(clin.idx, clin)
    mm = lmer(frm, data = labs.vitals.tmp[train,])
    cf = coef(mm)
    vit = "Pulse"
    #qq = qplot(cf$ANON_ID[vit], geom="histogram")  + weartals_theme + xlab(paste0(top8[i]," ~ ",vit)) + ylab("count")
    #print(qq) 
    #, vp = viewport(layout.pos.row = matchidx$row,
    #                         layout.pos.col = matchidx$col))
    tt = labs.vitals.tmp[test,clin]
  
    # Evaluate LR model
    frm = paste0(clin," ~ Pulse + Temp")
    m0 = lm(frm, labs.vitals.tmp[train,])
    pp = predict(m0, newdata = labs.vitals.tmp[test,])
    #plot(pp, tt)
    lr.corr.coefs <- c(lr.corr.coefs, cor(pp,tt,use = "na.or.complete")) # corr coef of LR model
    
    # Evaluate MM model
    pp = predict(mm, newdata = labs.vitals.tmp[test,])
    #plot(pp, tt)
    mm.corr.coefs<-c(mm.corr.coefs, cor(pp,tt,use = "na.or.complete")) # corr coef of MM model
    
    # Evaluate LR model with ID
    frm = paste0(clin," ~ ANON_ID")
    m0 = lm(frm, labs.vitals.tmp[train,])
    pp = predict(m0, newdata = labs.vitals.tmp[test,])
    #plot(pp, tt)
    id.corr.coefs <- c(id.corr.coefs, cor(pp,tt,use = "na.or.complete")) # corr coef of LR model only with patient ID
  }
}
indiv.corr.coefs <- cbind(lr.corr.coefs, mm.corr.coefs, id.corr.coefs)
rownames(indiv.corr.coefs) <- clin.idx
write.table(indiv.corr.coefs, "../SECURE_data/20180329_indiv_30k_corr_coeffs.csv",row.names=TRUE,col.names=TRUE, sep=",")
data <-read.table("../SECURE_data/20180330/20180329_indiv_30k_corr_coeffs.csv",
                  header=TRUE,sep=',',stringsAsFactors=FALSE)
d <- melt(data, id.vars="X")
ggplot(d, aes(x=X, y=value, col=variable, shape=variable))+
  geom_point(cex=2.5) + 
  weartals_theme




####################
# Suppl. Figure 1  #
####################
iPOPtopTen <- c( "PLT",
                 "ALKP",
                 "BUN",
                 "MONOAB",
                 "HSCRP",
                 "GLU",
                 "GLOB",
                 "A1C",
                 "WBC",
                 "IGM" )

pList <- list(); j=0  
for (i in iPOPtopTen){
  j=j+1
  call <-paste0("iPOPcorDf$",i)
  df <- cbind(iPOPcorDf[[i]], iPOPcorDf[,c("Pulse", "Temp")])
  df <- na.omit(df)
  #pList[[j]] <- 
  print(ggplot(df, aes(x = df$Pulse, y = df[,1])) +
        geom_point(col="black", pch=19, cex=0.5) +
        stat_smooth(method = "lm", formula = y  ~ x + I(x^2), size = 1.5, col="darkred") +
        theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
        xlab("cHR") + ylab(i)) }
#grid.arrange(pList[[1]],pList[[2]],pList[[3]],pList[[4]],pList[[5]],pList[[6]], ncol=2,top="Main Title")
#####
# iPOP binning plot figures
#####
summary.pulse<-list()
summary.Temp<-list()
r.squared <-c()
for (j in clinTopTen){
  iPOPcorDf$bin2<-ntile(iPOPcorDf[[j]], 40)
  # for Temp
  # corDf2 <- summarySE(corDf, measurevar="Temp", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Temp)) +
  # geom_point(stat="identity", fill="darkblue") +
  #   geom_errorbar(aes(ymin=Temp-se, ymax=Temp+se), width=.4) +
  #   xlab(paste(c(j, "bins", sep=" ")))+
  #   scale_y_continuous(limits = c(97,99)) 
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  # For Pulse
  iPOPcorDf2 <- summarySE(iPOPcorDf, measurevar="Pulse", groupvars="bin2", na.rm=TRUE)
  # print(ggplot(corDf2, aes(x=bin2, y=Pulse)) +
  #  geom_bar(stat="identity", fill="darkred") +
  # geom_errorbar(aes(ymin=Pulse-se, ymax=Pulse+se), width=.2) +
  # xlab(paste(c(j, "bins", sep=" ")))
  # + theme(text = element_text(size=9),
  #         axis.text.x = element_text(angle = 60, hjust = 1)))
  print(paste0(j, ": number of data points in bin = ", sum(iPOPcorDf$bin2 %in% "2")))
  print(ggplot(iPOPcorDf2, aes(x = bin2, y = Pulse)) +
          stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkred") +
          theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
          geom_point(col="black") +
          xlab(paste0(c(j ," Bin"))))
  summary.pulse <- summary(lm(iPOPcorDf2$Pulse ~ iPOPcorDf2$bin2 + I(iPOPcorDf2$bin2^2)))
  r.squared[j] <- summary.pulse$adj.r.squared
  # print(ggplot(corDf2, aes(x = bin2, y = Temp)) +
  #         stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1.5, col="darkblue") +
  #         geom_point(col="black") +
  #         #ylim(c(96,98.5))+
  #         theme(axis.title=element_text(face="bold",size="14"),axis.text=element_text(size=16,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"))+
  #         xlab(paste0(c(j ," Bin"))))
  # summary.Temp <- summary(lm(corDf2$Temp ~ corDf2$bin2 + I(corDf2$bin2^2)))
  # r.squared[j] <- summary.Temp$adj.r.squared
  
}
as.matrix(r.squared)



##################
# Suppl. Fig 2A  #
##################
plot(corDf$Pulse ~ corDf$NEUT, pch='.',
     xlab="Neutrophils", ylab="Pulse", font.lab=2,lwd=2,font=2)
abline(lm(corDf$Pulse ~ corDf$NEUT+ (corDf$NEUT)^2), col="blue",lwd=4)

#############################
#    Suppl. Table 2 and 3   #
#############################
# allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
#              "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
#              "CR","EOS","EOSAB","ESR", "GLOB","GLU_byMeter",
#              "GLU_fasting","GLU_nonFasting","GLU_SerPlas",
#              "GLU_wholeBld","HCT","HDL",
#              "HGB","HSCRP","IGM","K","LDL_Calc", "LDL_Direct","LDLHDL","LYM","LYMAB",
#              "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
#              "NEUTAB","NHDL","PLT","PROCALCITONIN", "RBC","RDW","TBIL","TGL","TP","TroponinI","WBC")# RUN 30K CORRELATIONS 
allClin <- c("A1C","AG","ALB","ALKP","ALT","AST","BASO",
             "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
             "CR","EOS","EOSAB","ESR", "GLOB",
             "GLU_fasting","HCT","HDL",
             "HGB","HSCRP","IGM","K","LDL_Direct","LDLHDL","LYM","LYMAB",
             "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
             "NEUTAB","NHDL","PLT","RBC","RDW","TBIL","TGL","TP","WBC")# RUN 30K CORRELATIONS

# for each lab run a multiple regression:
r<-c()
p<-c()
fstat <-c()
degfree <- c()
tot= 0 
for (i in allClin){
  call <-paste0("corDf$",i)
  df <- cbind(corDf[[i]], corDf[,c("Pulse", "Temp")])
  df <- na.omit(df)
  #tot = tot + length(df$Pulse)
  print(c(i , length(df$Pulse))) # the number of each clinical lab test that has corresponding vital signs
  m <- summary(lm(df[,1] ~ df$Pulse + df$Temp)) # bivariate with pulse + temp
  #m <- summary(lm(df[,1] ~ df$Pulse)) # univariate with pulse or temp only
  #m <- summary(lm(df[,1] ~ df$Temp + I(df$Temp^2))) # quadratic univariate with pulse or temp only
  r[i]<-m$adj.r.squared 
  fstat[i]<-m$fstatistic
  p[i]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3])
  degfree[i]<-m$df
}

options("scipen"=100, "digits"=4)
str(data.frame(as.list(r)))
str(data.frame(as.list(p))); p<-sort(p) 
str(data.frame(as.list(fstat)))
tot # total number of labs that have clin vitals measures corresponding to it

# num lab tests in iPOP dataset
tot <- 0; for (i in 7:56){
  tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot 

# num vital signs in iPOP dataset
tot <- 0; for (i in 7:56){tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot




##############
#  Figure 2B #
##############
# make boxplots for the top best correlated clinic values with vital signs in the 30k cohort

#topHits <- c("GLU_fasting","HSCRP","ESR", "NEUT","RDW","LYM", "ALB", "PROCALCITONIN")
#topHits <- c("HSCRP","NEUTAB","NEUT","LYM", "PLT", "TroponinI", "ESR", "PROCALCITONIN")

for (i in clinTopTen){
  #quartile
  #below<-corDf$Temp[corDf[i] < summary(corDf[i])[5]]
  #above<-corDf$Temp[corDf[i] > summary(corDf[i])[5]]
  #decile
  below<- corDf$Temp[sapply(ntile(corDf[i], 40) <= 1, isTRUE)]
  #fifth<- corDf$Temp[ntile(corDf[i], 40) <= 6 & ntile(corDf[i], 40) >= 4 & !is.na(ntile(corDf[i], 40))]
  #tenth<- corDf$Temp[ntile(corDf[i], 40) <= 11 & ntile(corDf[i], 40) >= 9 & !is.na(ntile(corDf[i], 40))]
  above<- corDf$Temp[sapply(ntile(corDf[i], 40) >= 40, isTRUE)]
  print(paste0(i, ": number in upper is ", length(below), " and number of lower is ", length(above)))
  pval<-round(unlist(t.test(below, above)[3]), digits=3)
  #boxplot(below,above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 3rd Quartile","Above 3rd Quartile"), ylab="Temp")
  #boxplot(below,fifth, tenth, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","fifth ventile", "tenth ventile","Above 10th ventile"), ylab="Temp")
  boxplot(below, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Lowest","Highest"), ylab="Temp", col="lavenderblush4")
  #color for skin temp is lavenderblush4
}

# check diabetes ones:
for (i in topHits){
  normal<- corDf$Temp[corDf$GLU_fasting < 100]
  prediabetes<- corDf$Temp[corDf$GLU_fasting > 100 & corDf$GLU_fasting < 110]
  diabetes<- corDf$Temp[ntile(corDf[i], 40) <= 11 & ntile(corDf[i], 40) >= 9 & !is.na(ntile(corDf[i], 40))]
  print(paste0(i, ": number in upper is ", length(below), " and number of lower is ", length(above)))
  pval<-round(unlist(t.test(below, above)[3]), digits=3)
  #boxplot(below,above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 3rd Quartile","Above 3rd Quartile"), ylab="Temp")
  #boxplot(below,fifth, tenth, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","fifth ventile", "tenth ventile","Above 10th ventile"), ylab="Temp")
  boxplot(below, above, outline=FALSE, main=paste(i,", P=", pval, sep=""), names=c("Below 1st ventile","Above 10th ventile"), ylab="Temp")
}



############
# Figure 4 #
############
library(lme4)
topNeut <- names(head(sort(pulse.num.top.quartile, decreasing = TRUE), 20)) #the 20 people that had the most measurements of NEUT (between 67 and 171 measurements)
p1 <- ggplot(data = corDf[corDf$ANON_ID %in% topNeut,], aes(x = NEUT, y = Temp, colour = ANON_ID)) +       
  #geom_point() + 
  #geom_smooth(method='lm',formula=y~x, se = FALSE)
  geom_smooth(method='loess',formula=y~x, se = FALSE)
#  geom_smooth(method = "lm", formula = y ~ splines::bs(x, 2), se = FALSE)
model <- lmList(NEUT ~ Temp | ANON_ID, data=corDf)

na.omit(corDf) %>% 
  group_by(ANON_ID) %>% 
  do({
    mod = lm(NEUT ~ Temp, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2])
  })



#########################
# Supplementary Table 1 #
#########################
# get mean +/- SE for each of the 50 clin values
library("psych")
thirtyk.summary <- describe(corDf)

# get p-values and rsquared of univariate correlations
vitalVars <- which(names(corDf) %in% c("Pulse","Temp"))
results <- corr.test(corDf[,3:56],
                     corDf[,c(vitalVars)],
                     method="pearson",adjust="fdr")
#### CREATE DATA FRAME(S) SUMMARIZING RESULTS ####
rCols <- paste0(dimnames(results$r)[[2]],"_R")
pCols <- paste0(dimnames(results$p)[[2]],"_P")
nCols <- paste0(dimnames(results$n)[[2]],"_N")
allCors_R <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_R) <- dimnames(results$r)[[1]]
for(i in 1:length(rCols)){
  allCors_R[,i] <- results$r[,i]
  names(allCors_R)[i] <- rCols[i]
}

allCors_P <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_P) <- dimnames(results$p)[[1]]
for(i in 1:length(pCols)){
  allCors_P[,i] <- results$p[,i]
  names(allCors_P)[i] <- pCols[i]
}

allCors_N <- data.frame(placeHolder=rep(NA,length(allClin)))
rownames(allCors_N) <- dimnames(results$n)[[1]]
for(i in 1:length(nCols)){
  allCors_N[,i] <- results$n[,i]
  names(allCors_N)[i] <- nCols[i]
}

allCors <- cbind(allCors_R,allCors_P,allCors_N)

newColOrder <- c("Pulse","Temp")

tmp <- allCors
for(i in 1:length(newColOrder)){
  if(i == 1){
    cache <- grep(newColOrder[i],names(allCors))
    tmp[,c(i:sum(0+3))] <- allCors[,c(cache)]
    names(tmp)[c(i:sum(0+3))] <- c(names(allCors)[c(cache)])
    count <- sum(0+3)
  } else {
    if(i != 1){
      cache <- grep(paste0("^",newColOrder[i]),names(allCors))
      tmp[,c(sum(count+1):sum(count+3))] <- allCors[,c(cache)]
      names(tmp)[c(sum(count+1):sum(count+3))] <- c(names(allCors)[c(cache)])
      count <- sum(count+3)
    }
  }
}

allCors <- tmp
sigCors_Ranked <- allCors

#class(sigCors_Ranked$Pulse_P)
sigCors_Ranked <- sigCors_Ranked[
  which(sigCors_Ranked$Pulse_P < 0.05),]

sigCors_Ranked <- sigCors_Ranked[
  order(abs(sigCors_Ranked$Pulse_R),decreasing = TRUE),]

#### SAVE DATA FRAME(S) SUMMARIZING RESULTS ####

write.csv(allCors,
          "~/Desktop/20170810_allCors_VitalsVsLabs.csv",
          row.names=TRUE)

write.csv(sigCors_Ranked,
          "~/Desktop/20170810_sigCorsRanked_VitalsVsLabs.csv",
          row.names=TRUE)

################################
#  Currently not used in paper #
################################

# RUN iPOP CORRELATIONS between labs and vitals
options("scipen"=100, "digits"=4)
models=c(" ~ Pulse", # univariate with pulse only
         " ~ Temp",   # univariate with temp only
         " ~ Pulse + Temp", # bivariate with pulse + temp
         " ~ Pulse + I(Pulse^2)",
         " ~ Temp + I(Temp^2)" )

for (k in 1:length(models)){
  print(k)
  r<-matrix(ncol = length(unique(iPOPcorDf$iPOP_ID)),nrow = length(allClin),
            dimnames=list(
              c(allClin),
              c(unique(iPOPcorDf$iPOP_ID))))
  rsq.pred <-r; p<-r; fstat <-r; degfree <- r; numObs <-r;
  tmp=0
  for (i in allClin){ # for each of the 50 clinical lab tests
    tmp=tmp+1 # counter for index of allClin
    tmp2=0    # counter for index of iPOP_ID
    for (j in unique(iPOPcorDf$iPOP_ID)){ 
      tmp2=tmp2+1  # counter for index of iPOP_ID
      iPOPcorDf2 <- iPOPcorDf[!(iPOPcorDf$iPOP_ID %in% j),] # leave one person out
      df <- cbind(iPOPcorDf2[[i]], iPOPcorDf2[,c("Pulse", "Temp")])
      df <- na.omit(df)
      model<-lm(as.formula(paste0(i,models[k])),data=iPOPcorDf2)
      m <- summary(model) # quadratic univariate with pulse or temp only
      # r[tmp,tmp2]<-m$adj.r.squared # matrix of r-squared values for each left-one-out model
      # p[tmp,tmp2]<-1-pf(m$fstatistic[1],m$fstatistic[2],m$fstatistic[3]) # matrix of p-squared values for each left-one-out model
      numObs[tmp,tmp2]<-length(df$Pulse) # the number of each clinical lab test that has corresponding vital signs
      iPOPcorDf3 <- iPOPcorDf[(iPOPcorDf$iPOP_ID %in% j),] # test set (the one person that was left out)
      df3 <- cbind(iPOPcorDf3[[i]], iPOPcorDf3[,c("Pulse", "Temp")])
      df3 <- na.omit(df3)
      pred=predict(model, newdata=df3)# prediction on test person
      rsq.pred[tmp,tmp2] = 1 - (mean( (pred - df3[,1])**2 ) / var( (df[,1]) )) # test r.sq
    }
  }
  name.rsq <- paste("model.mean.rsq", k, sep = "")
  assign(name.rsq, data.frame(model = name.rsq, test = allClin, means = rowMeans(rsq.pred), sd =apply(rsq.pred, 1, sd))) 
}

rsq.plot<- as.data.frame(as.list((rbind(model.mean.rsq1, model.mean.rsq2, model.mean.rsq3, model.mean.rsq4, model.mean.rsq5))))
rsq.plot$model <- mapvalues(rsq.plot$model, from = c("model.mean.rsq1", "model.mean.rsq2", "model.mean.rsq3", "model.mean.rsq4", "model.mean.rsq5"), to = c("~ Pulse", "~ Temp", "~ Pulse + Temp", " ~ Pulse + I(Pulse^2)", " ~ Temp + I(Temp^2)"))

# plot how rsq changes with the different models, and add in error bars from sd.plot
ggplot(rsq.plot, aes(x=test, y=means, group=model, col=as.factor(rsq.plot$model))) +
  geom_point() +
  theme(axis.title=element_text(face="bold",size="12"),axis.text=element_text(size=12,face="bold"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
        axis.text.x = element_text(angle = 60, hjust = 1)) +
  xlab("Clinical Laboratory Test") + ylab("Cross-Validated R-squared (+/- SD)") +
  labs(linetype='Model')
guides(guide_legend(title="Model"))
#guides(fill=guide_legend(title="Model"))
scale_fill_discrete(name="Model")+
  geom_errorbar(aes(ymin=means-sd, ymax=means+sd), width=0.7,
                position=position_dodge(.7)) + ylim(0,1.5)

tot # total number of labs that have clin vitals measures corresponding to it
# num lab tests in iPOP dataset
tot <- 0; for (i in 7:56){
  tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot 

# num vital signs in iPOP dataset
tot <- 0; for (i in 7:56){tmp <- length(as.matrix(na.omit(wear[i]))); tot <- tot + tmp}; tot



#### END ####


