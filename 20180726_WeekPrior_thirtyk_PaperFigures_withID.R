
# Framework Paper Figures
# built from 20170905_thirtyk.R

#### OUTPUT: Figures for paper

#### LIBRARY DEPENDENCIES:
library(ggplot2)
library(data.table)
library(psych)
library(nlme)
library(MuMIn)
library(Rmisc)
library(gridExtra)
library(grid)
library(dplyr)
library(MASS)
library("ggthemes")
library(reshape2)
library(randomForest)
library("glmnet")

if(!dir.exists("plots")) dir.create("plots")

# FUNCTIONS
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

# Path to the directory with data
dir = "../SECURE_data/"

###################
#### READ DATA ####
###################

#iPOP wearables/clinical combined data
# wear <- read.csv(paste0(dir, "Basis2016_Cleaned_NotNorm0824_WeekPrior.csv"),
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for Lukasz script
# do not use:  wear <- read.csv("/Users/jessilyn/Documents/Career_Development/Mentoring/RyanRunge/20170803_FINAL_LASSOS/Basis2016_Norm0824_WeekPrior.csv",
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for other figures, may need to resurrect this one
timespans <-c("AllData",
              "MonthPrior",
              "2WeekPrior",
              "WeekPrior",
              "5DayPrior",
              "3DayPrior",
              "DayPrior" )

wear <- read.csv(paste0("/srv/gsfs0/projects/snyder/jdunn/framework_paper/Basis_Timespan_Subset_Tables/",
                "Basis2016_Clean_Norm_", timespans[4], "_20180504.csv"),
                 header=TRUE,sep=',',stringsAsFactors=FALSE)

# iPOP vitals (called vitals in Lukasz script)
#setwd("/Users/jessilyn/Desktop/framework_paper/weartals")
iPOPvitals <- read.csv(paste0(dir, "vitals.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP Labs (called labs in Lukasz script)
iPOPlabs <- read.csv(
  paste0(dir, "lab_results_20170717.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

# 30k vitals
vitals <- fread(paste0(dir, "all_vitals.csv"),
                header=TRUE,sep=',',stringsAsFactors=FALSE)
vitals <- data.frame(vitals)
# 30k labs
labs <- fread(paste0(dir, "all_labs.csv"),
              header=TRUE,sep=',',stringsAsFactors=FALSE)
# 30K labs/vitals combined file <- generated by 20170908_thirtyk.R or 20180412_thirtyk.R (where new vitals like BP and respiration are added in)
# corDf <- read.csv(paste0(dir, "20170905_Cleaned_joined_30k_labs_vitals.csv"),
#                    header=TRUE,sep=',',stringsAsFactors=FALSE)
corDf <- read.csv(paste0(dir, "20180412_Cleaned_joined_30k_labs_ALLvitals.csv"),
                   header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP demographics
iPOPdemographics <- read.csv(paste0(dir, "SECURE_ClinWearDemo_SamplePop.csv"),
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

#thirtyK demographics
thirtyKdemog <- read.csv(paste0(dir, "SECURE_20180412_thirtyKDemog.csv"),
         header=TRUE,sep=',',stringsAsFactors=FALSE)

# names of top clinical tests that will be used for the downstream analyses
top.names<-top.names<-c("LYM", "NEUT", "LYMAB", "NEUTAB", "IGM", "HSCRP", "ALKP", "ALT", "HDL", "MCV", "TBIL", "CHOLHDL", "GLOB", "AG", "CO2", "CA", "LDLHDL", "BUN", "NHDL", "NA.", "UALB", "MONOAB", "CHOL", "MONO", "RDW", "HCT", "TP", "TGL", "EOS", "LDL", "GLU", "AST", "PLT", "K", "EOSAB", "BASOAB", "MCH", "ALB", "HGB", "A1C", "CL", "RBC", "BASO", "MCHC") # names of lab tests from the 30k simple bivariate models

###################
### CLEAN DATA ####
###################

### clean iPOP Vitals ###
names(iPOPvitals)[which(names(iPOPvitals)=="HIMCID")] <- "iPOP_ID"
names(iPOPvitals)[which(names(iPOPvitals)=="RECORDED_TIME")] <- "Clin_Result_Date"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Pulse.")] <- "Pulse"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Temp.")] <- "Temp"
names(iPOPvitals)[which(names(iPOPvitals)=="X.BP.")] <- "BP"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Bmi.")] <- "BMI"

for (i in 1:length(iPOPvitals$BP)){
  iPOPvitals$systolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][1]
  iPOPvitals$diastolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][2]
}

#Reformat dates
iPOPvitals$Clin_Result_Date <- format(
  as.Date(iPOPvitals$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

#Make correlation variables numeric
iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")] <- apply(
  iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")], 2,
  function(x) as.numeric(as.character(x)))

#### CLEAN iPOP LABS DATA ####

#Rename columns
names(iPOPlabs)[which(names(iPOPlabs)=="HIMC_ID")] <- "iPOP_ID"
names(iPOPlabs)[which(names(iPOPlabs)=="RESULT_TIME")] <- "Clin_Result_Date"

#Reformat dates
iPOPlabs$Clin_Result_Date <- format(
  as.Date(iPOPlabs$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

# allClin <- c("A1C","AG","ALB","ALCRU","ALKP","ALT","AST","BASO",
#              "BASOAB","BUN","CA","CHOL","CHOLHDL","CL","CO2",
#              "CR","EGFR","EOS","EOSAB","ESR","GLOB","GLU","HCT","HDL",
#              "HGB","HSCRP","IGM","K","LDL","LDLHDL","LYM","LYMAB",
#              "MCH","MCHC","MCV","MONO","MONOAB","NA.","NEUT",
#              "NEUTAB","NHDL","PLT", "RBC","RDW","TBIL","TGL","TP","UALB","UALBCR","WBC") 

allClin <- c("ALKP", "LYM", "HSCRP", "ALT", "NEUT", "TBIL", "IGM", "TGL", "MCV", "MCH", "CO2", "LYMAB", "NEUTAB", "UALB", "CHOL", "MONOAB", "ALB", "NA.", "HDL", "PLT", "AG", "HGB", "EOS", "CL", "BUN", "GLOB", "CA", "CHOLHDL", "HCT", "BASOAB", "A1C", "GLU", "LDLHDL", "TP", "EOSAB", "K", "NHDL", "RBC", "MONO", "AST", "MCHC", "RDW", "BASO", "LDL")

for(i in 1:length(allClin)){ #this removes non-numeric characters
  cache <- iPOPlabs[,c(allClin[i])]
  cache <- gsub("[^0-9.]","",cache) #this keeps decimals
  iPOPlabs[,c(allClin[i])] <- cache
}
#Make correlation variables numeric
iPOPlabs[,c(allClin)] <- apply(
  iPOPlabs[,c(allClin)], 2,
  function(x) as.numeric(as.character(x)))

#subset by allClin
iPOPlabs <- iPOPlabs[names(iPOPlabs) %in% c("iPOP_ID","Clin_Result_Date",allClin)]

#Merge data
iPOPcorDf <- merge(iPOPlabs,
                   iPOPvitals[,c("iPOP_ID","Clin_Result_Date",
                                 "Pulse","Temp","BMI","systolic","diastolic")],
                   by=c("iPOP_ID","Clin_Result_Date"))

### clean iPOPcorDf ###
iPOPcorDf[, -c(1,2)] <- apply(iPOPcorDf[, -c(1,2)], 2, remove_outliers)

### clean corDf ### 
corDf[, -c(1,2)] <- apply(corDf[, -c(1,2)], 2, remove_outliers) 

### clean wear ### messes up code for Fig 2C so edited it out, but might be necessary for the CCA in Fig 2E
# wear2<-wear
# wear[,-c(1:6)] <- sapply(wear[,-c(1:6)], as.numeric)
# wear[,-c(1:6)] <- apply(wear[,-c(1:6)], 2, remove_outliers) 

## merge iPOP and demographics
iPOPcorDf.demo <- merge(iPOPcorDf, iPOPdemographics[1:4], by="iPOP_ID")


###############
#  Figure 2D  #
###############

# creates ranked list of clinical laboratory tests by the %var explained in simple LM; LOO cross validation at the subject level 

source("ggplot-theme.R") # just to make things look nice

# choose for during troubleshooting
use.Troubleshoot.mode = FALSE
#choose whether Demographics in models (supply TRUE or FALSE)
use.Demog <- FALSE
#choose whether iPOP_ID variable is used (supply TRUE or FALSE)
use.iPOP <- TRUE

if (use.Troubleshoot.mode){
  top.names<-c("MONOAB", "HGB", "HCT", "RBC") # "RBC", "PLT") # for testing model on small subset
}

####
# CODE FOR SIMPLE LM
#
sum.vectors.in.list <- function(x) {
  c(sum(na.omit(x)))
}

rsq.all = c()
pct.var.all = c()
iPOPcorDf.demo <- merge(iPOPcorDf, iPOPdemographics[1:4], by="iPOP_ID")
iPOPcorDf.demo$Gender <- as.factor(iPOPcorDf.demo$Gender)
iPOPcorDf.demo$Ethn <- as.factor(iPOPcorDf.demo$Ethn)

#change gender and ethnicity to dummy variables
gender <- data.frame(model.matrix( ~ Gender - 1, data=iPOPcorDf.demo))
ethn <- data.frame(model.matrix( ~ Ethn - 1, data=iPOPcorDf.demo))

#remove the least populated gender and ethnicity (NCOL-1)
cache <- names(gender)[which(sapply(gender,sum)==max(sapply(gender,sum)))]
gender <- data.frame(cache=gender[which(sapply(gender,sum)==max(sapply(gender,sum)))])
ethn <- ethn[,-which(sapply(ethn,sum)==min(sapply(ethn,sum)))]
#cbind new gender and ethnicity variables to "wear"
iPOPcorDf.demo <- cbind(iPOPcorDf.demo,gender,ethn)

#store names as vitals.variables
#vitals.variables <- c("Pulse", "Temp", "AgeIn2016", names(gender), names(ethn)) # "BMI", "systolic", "diastolic", 
if(use.Demog){
  vitals.variables <- c("Pulse", "Temp", "AgeIn2016", "Gender", "Ethn") # "BMI", "systolic", "diastolic", 
} else if(!use.Demog) {
  vitals.variables <- c("Pulse", "Temp") #
}

patients = unique(iPOPcorDf$iPOP_ID)

val.true <- rep(list(NA),length(top.names)) # list of vectors to store true values; each vector is for 1 clinical lab
val.pred <- rep(list(NA),length(top.names)) # list of vectors to store trained model predicted values; each vector is for 1 clinical lab
val.null.pred <- rep(list(NA),length(top.names)) # list of vectors to store null model predicted values; each vector is for 1 clinical lab
# p.value<-list()  # TODO: decide if this is a relevant parameter to collect - I think not...?
num.true <- rep(list(NA),length(top.names)) # number of observations per individual per clinic test

for (k in 1:length(patients)){
  train <- patients[patients != patients[k]]
  test <- patients[patients == patients[k]]
  cat("Patient",patients[k],"\n") # LOO
  dat.train.unsorted<-iPOPcorDf.demo[ iPOPcorDf.demo$iPOP_ID %in% train, ] # subset input data by training set
  dat.train <- dat.train.unsorted[order(dat.train.unsorted$iPOP_ID),] #order by iPOP_ID in order to supply correct nfolds arg to glmnet
  dat.test<-iPOPcorDf.demo[ iPOPcorDf.demo$iPOP_ID %in% test, ] # subset input data by testing set
  
  for (l in 1:length(top.names)){
    cat("Test",top.names[l],"\n")
    # create training set
    x.train<-dat.train[,colnames(dat.train) %in% c("iPOP_ID",top.names[l], vitals.variables)] # subset input data by lab: only take current lab test of interest
    x.train<- na.omit(x.train) # skip nas and nans ## TODO: the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
    x.train.ids<-x.train$iPOP_ID
    x.train<-x.train[,-1]
    predictors <- as.data.frame(x.train[,colnames(x.train) %in% c(vitals.variables)]) # later add in demographics
    outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
    # create test set
    x.test<-dat.test[,colnames(dat.test) %in% c(top.names[l], vitals.variables)] # subset input data by lab: only take current lab test of interest
    x.test<- na.omit(x.test) # skip nas and nans ## TODO: SEE ABOVE na.omit FOR ISSUE WITH THIS
    val.true[[l]] = c(val.true[[l]], x.test[,top.names[l]]) # true values of left out person
    num.true[[l]]<-c(num.true[[l]],length(x.test[,top.names[l]])) # number of test observations for left out person
    fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(vitals.variables,collapse=" + "))
    fml.null = paste(top.names[l]," ~ 1")
    bivar.lm.model = lm(as.formula(fml), data = x.train) # build the model
    val.pred[[l]] = c(val.pred[[l]], predict(bivar.lm.model, newdata = x.test)) # predict on trained model
    bivar.null.lm.model<-lm(as.formula(fml.null), data = x.train) # create null model for hypothesis testing and for calculating RSS0
    val.null.pred[[l]] = c(val.null.pred[[l]], predict(bivar.null.lm.model, newdata = x.test)) # predict on null model
    # t<- anova(bivar.null.lm.model, bivar.lm.model) # to get p-values for model
    # p.value[[l]] <- as.numeric(t[2,][["Pr(>F)"]])  # to get p-values for model
  }
}
num.test.obs <- lapply(num.true, sum.vectors.in.list)

rsq.vitals = c()
rssm.vitals = c()
rss0.vitals = c()
pct.var.explained = c()
num.Records.check <- c()
for (j in 1:length(top.names)){
  rsq.vitals = c(rsq.vitals, cor(val.pred[[j]], val.true[[j]], use = "complete.obs"))
  rssm.vitals = sum(na.omit((val.true[[j]] - val.pred[[j]])^2))
  rss0.vitals = sum(na.omit((val.true[[j]] - val.null.pred[[j]])^2))
  pct.var.explained = c(pct.var.explained, (1 - ( rssm.vitals / rss0.vitals )))
  num.Records.check <- c(num.Records.check, (length(val.pred[[j]])-1)) # same as num.test.obs
}
names(rsq.vitals) = top.names
names(pct.var.explained) = top.names
sqrt.pct.var <- sqrt(pct.var.explained)
as.matrix(sort(sqrt(pct.var.explained)))
####
# CODE FOR LASSO, RF
####

#clean wear data frame
wear[,8:length(names(wear))] <- apply(
  wear[,8:length(names(wear))], 2,
  function(x) as.numeric(as.character(x)))
wear$Gender <- as.factor(wear$Gender)
wear$Ethn <- as.factor(wear$Ethn)
wear.variables <- unlist(read.table("FinalLasso_153WearableFactors.csv", stringsAsFactors = FALSE)) # the table of model features we want to work with

#change gender and ethnicity to dummy variables
gender <- data.frame(model.matrix( ~ Gender - 1, data=wear))
ethn <- data.frame(model.matrix( ~ Ethn - 1, data=wear))

#remove the least populated gender and ethnicity (NCOL-1)
cache <- names(gender)[which(sapply(gender,sum)==max(sapply(gender,sum)))]
gender <- data.frame(cache=gender[which(sapply(gender,sum)==max(sapply(gender,sum)))])
ethn <- ethn[,-which(sapply(ethn,sum)==min(sapply(ethn,sum)))]

#store names as demo.variables
demo.variables <- c("AgeIn2016", names(gender), names(ethn))

#cbind new gender and ethnicity variables to "wear"
wear <- cbind(wear,gender,ethn)

val.true <- rep(list(NA),length(top.names)) # list of vectors to store true values; each vector is for 1 clinical lab
null.val.pred <- rep(list(NA),length(top.names))  # list of vectors to store nullmodel-predicted values; each vector is for 1 clinical lab
lasso.val.pred.lambda.manual <- rep(list(NA),length(top.names)) # list of vectors to store lasso-trainedmodel-predicted values; each vector is for 1 clinical lab
lasso.val.pred.lambda.min <- rep(list(NA),length(top.names)) # list of vectors to store lasso-trainedmodel-predicted values; each vector is for 1 clinical lab
lasso.val.pred.lambda.1se <- rep(list(NA),length(top.names)) # list of vectors to store lasso-trainedmodel-predicted values; each vector is for 1 clinical lab
rf.val.pred <- rep(list(NA),length(top.names))  # list of vectors to store rf-trainedmodel-predicted values; each vector is for 1 clinical lab

num.Records <- c()
lasso.features.lambda.manual <- data.frame("test"=character(),"cv.run"=character(),
                                           "left.out.person"=character(),"lasso.feature"=character(),
                                           "lasso.coef.value"=character())
lasso.features.lambda.min <- data.frame("test"=character(),"cv.run"=character(),
                                        "left.out.person"=character(),"lasso.feature"=character(),
                                        "lasso.coef.value"=character())
lasso.features.lambda.1se <- data.frame("test"=character(),"cv.run"=character(),
                                        "left.out.person"=character(),"lasso.feature"=character(),
                                        "lasso.coef.value"=character())
rf.features <- data.frame("test"=character(),"cv.run"=character(),
                          "left.out.person"=character(),"rf.feature"=character(),
                          "rf.coef.value"=character())

if(use.Demog){
  demo.variables <- c("AgeIn2016", names(gender), names(ethn))
} else if(!use.Demog) {
  demo.variables <- c()
}

for (k in 1:length(patients)){
  train <- patients[patients != patients[k]]
  test <- patients[patients == patients[k]]
  cat("Patient",patients[k],"\n") # LOO
  #set up iPOP dummy variable if use.iPOP=TRUE
  if(use.iPOP){
    cache <- data.frame(model.matrix( ~ iPOP_ID - 1, data=wear))
    cache <- cache[,-which(names(cache)==paste0("iPOP_ID",gsub("-",".",test)))]
    wear <- cbind(wear,cache)
    demo.variables <- c(demo.variables,names(cache)) #append iPOPs to demo
  } 
  dat.train.unsorted <- wear[ wear$iPOP_ID %in% train, ] # subset input data by training set
  dat.train <- dat.train.unsorted[order(dat.train.unsorted$iPOP_ID),] #order by iPOP_ID in order to supply correct nfolds arg to glmnet
  dat.test<-wear[ wear$iPOP_ID %in% test, ] # subset input data by testing set
  for (l in 1:length(top.names)){
    cat("Test",top.names[l],"\n")
    x.train<-dat.train[,colnames(dat.train) %in% c("iPOP_ID", top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
    x.train<-na.omit(x.train) # skip nas and nans ## TODO: the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
    x.train.ids<-x.train$iPOP_ID
    x.train<-x.train[,-1] 
    # if(!NROW(x.train)){ #if x.train is empty
    #   print(paste0("The x.train data was empty for ",patients[k],"'s ",top.names[l]," test."))
    # } else {
    #   print(paste0("The x.train data for ",patients[k],"'s ",top.names[l]," test had ",NROW(x.train)," observations."))
    # }
    predictors <- as.data.frame(x.train[,colnames(x.train) %in% c(wear.variables, demo.variables)]) # later add in demographics
    outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
    
    # create test set
    x.test<-dat.test[,colnames(dat.test) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
    x.test<- na.omit(x.test) # skip nas and nans ## TODO: SEE ABOVE na.omit FOR ISSUE WITH THIS
    # if(!NROW(x.test)){ #if x.test is empty
    #   print(paste0("The x.test data was empty for ",patients[k],"'s ",top.names[l]," test."))
    # } else {
    #   print(paste0("The x.test data for ",patients[k],"'s ",top.names[l]," test had ",NROW(x.test)," observations."))
    # }
    val.true[[l]] = c(val.true[[l]], x.test[,top.names[l]]) # true values of left out person
    
    num.Records <- rbind(num.Records, c(IPOP_ID=patients[k], test=top.names[l], TrainingObs=length(outcome), TestObs=length(x.test[,top.names[l]])))
    
    rf.variables.to.use = c(wear.variables, demo.variables) # rf variables (use all)
    
    #decide on number for nfolds from number of obs per subject
    frq <- as.vector(table(x.train.ids))
    
    #optional argument for leave-one-out CV method
    n <- length(frq)
    
    #optional argument to specify folds for CV
    folds <- rep(1:length(frq),frq[1:length(frq)])
    
    ## run lasso for variable selection
    # n <- as.numeric(length(outcome)) #optional argument for leave-one-out CV method for nfold
    x_train <- model.matrix( ~ .-1, as.data.frame(predictors))
    glm.res = cv.glmnet(x=x_train,y=outcome,
                        standardize.response=FALSE,
                        family="gaussian",
                        nfolds=n,
                        foldid=folds,
                        nlambda=100)
    
    #    lasso.model.lambda.min = lm(as.formula(lasso.fml.lambda.min), data = x.train) # , weights = labs.wear$weight) # TODO: do we need to include weights?    
    
    #store all lasso variable coefs (lambda specific: manual, min, and 1se)
    factors.lambda.manual = glm.res$glmnet.fit$beta[,25] # TODO: this is an arbitrary rule for now
    lasso.variables.lambda.manual = factors.lambda.manual#[abs(factors.lambda.manual)!=0]
    factors.lambda.min <- glm.res$glmnet.fit$beta[,which(glm.res$glmnet.fit$lambda==glm.res$lambda.min)]
    lasso.variables.lambda.min = factors.lambda.min#[abs(factors.lambda.min)!=0]
    factors.lambda.1se <- glm.res$glmnet.fit$beta[,which(glm.res$glmnet.fit$lambda==glm.res$lambda.1se)]
    lasso.variables.lambda.1se = factors.lambda.1se#[abs(factors.lambda.1se)!=0]
    
    ## pull out features from lasso models ##
    
    tmp <- data.frame("test"=rep(top.names[l],length(lasso.variables.lambda.manual)),
                      "cv.run"=rep(k,length(lasso.variables.lambda.manual)),
                      "left.out.person"=rep(patients[k],length(lasso.variables.lambda.manual)),
                      "lasso.feature"=names(lasso.variables.lambda.manual),
                      "lasso.coef.value"=as.numeric(lasso.variables.lambda.manual))
    lasso.features.lambda.manual <- rbind(lasso.features.lambda.manual,tmp)
    
    tmp <- data.frame("test"=rep(top.names[l],length(lasso.variables.lambda.min)),
                      "cv.run"=rep(k,length(lasso.variables.lambda.min)),
                      "left.out.person"=rep(patients[k],length(lasso.variables.lambda.min)),
                      "lasso.feature"=names(lasso.variables.lambda.min),
                      "lasso.coef.value"=as.numeric(lasso.variables.lambda.min))
    lasso.features.lambda.min <- rbind(lasso.features.lambda.min,tmp)
    
    tmp <- data.frame("test"=rep(top.names[l],length(lasso.variables.lambda.1se)),
                      "cv.run"=rep(k,length(lasso.variables.lambda.1se)),
                      "left.out.person"=rep(patients[k],length(lasso.variables.lambda.1se)),
                      "lasso.feature"=names(lasso.variables.lambda.1se),
                      "lasso.coef.value"=as.numeric(lasso.variables.lambda.1se))
    lasso.features.lambda.1se <- rbind(lasso.features.lambda.1se,tmp)
    
    #store lasso variable names based on coef threshold (lambda specific: manual, min, and 1se)
    lasso.variables.to.use.lambda.manual = names(factors.lambda.manual[abs(factors.lambda.manual)>1e-10]) # TODO: this is an arbitrary rule for now
    lasso.variables.to.use.lambda.min = names(factors.lambda.min[abs(factors.lambda.min)>1e-10])
    lasso.variables.to.use.lambda.1se = names(factors.lambda.1se[abs(factors.lambda.1se)>1e-10])
    
    # build null, lasso, and rf models
    set.seed(1)
    null.fml = paste(top.names[l]," ~ 1")
    null.model = lm(as.formula(null.fml), data = x.train) # create null model for hypothesis testing and for calculating RSS0
    null.val.pred[[l]] = c(null.val.pred[[l]], predict(null.model, newdata = x.test)) # predict on null model
    
    lasso.fml.lambda.manual = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(lasso.variables.to.use.lambda.manual,collapse=" + "))
    # lasso.model.lambda.manual = lm(as.formula(lasso.fml.lambda.manual), data = x.train) # , weights = labs.wear$weight) # TODO: do we need to include weights?
    # lasso.val.pred.lambda.manual[[l]] = c(lasso.val.pred.lambda.manual[[l]], predict(lasso.model.lambda.manual, newdata = x.test)) # predict on trained model
    # check that the formula is valid (i.e. not empty)
    if(lasso.fml.lambda.manual!=paste0("cbind( ",top.names[l]," ) ~ ")){
      lasso.model.lambda.manual = lm(as.formula(lasso.fml.lambda.manual), data = x.train) # , weights = labs.wear$weight) # TODO: do we need to include weights?
      lasso.val.pred.lambda.manual[[l]] = c(lasso.val.pred.lambda.manual[[l]], predict(lasso.model.lambda.manual, newdata = x.test)) # predict on trained model
    } else {
      lasso.model.lambda.manual = null.model # if lasso sets all coeffs = 0, then use the null model
      lasso.val.pred.lambda.manual[[l]] = c(lasso.val.pred.lambda.manual[[l]], predict(lasso.model.lambda.manual, newdata = x.test)) # predict on trained model
      # cache <-  length(val.true[[l]])-length(lasso.val.pred.lambda.manual[[l]])
      # lasso.val.pred.lambda.manual[[l]] = c(lasso.val.pred.lambda.manual[[l]], rep(NA,cache)) # fill with NA(s) if invalid model was supplied
    }
    
    lasso.fml.lambda.min = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(lasso.variables.to.use.lambda.min,collapse=" + "))
    #check that the formula is valid (i.e. not empty)
    if(lasso.fml.lambda.min!=paste0("cbind( ",top.names[l]," ) ~ ")){
      lasso.model.lambda.min = lm(as.formula(lasso.fml.lambda.min), data = x.train) # , weights = labs.wear$weight) # TODO: do we need to include weights?
      lasso.val.pred.lambda.min[[l]] = c(lasso.val.pred.lambda.min[[l]], predict(lasso.model.lambda.min, newdata = x.test)) # predict on trained model
    } else {
      lasso.model.lambda.min = null.model # if lasso sets all coeffs = 0, then use the null model
      lasso.val.pred.lambda.min[[l]] = c(lasso.val.pred.lambda.min[[l]], predict(lasso.model.lambda.min, newdata = x.test)) # predict on trained model
      # cache <-  length(val.true[[l]])-length(lasso.val.pred.lambda.min[[l]])
      # lasso.val.pred.lambda.min[[l]] = c(lasso.val.pred.lambda.min[[l]], rep(NA,cache)) # fill with NA(s) if invalid model was supplied
    }
    
    lasso.fml.lambda.1se = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(lasso.variables.to.use.lambda.1se,collapse=" + "))
    #check that the formula is valid (i.e. not empty)
    if(lasso.fml.lambda.1se!=paste0("cbind( ",top.names[l]," ) ~ ")){
      lasso.model.lambda.1se = lm(as.formula(lasso.fml.lambda.1se), data = x.train) # , weights = labs.wear$weight) # TODO: do we need to include weights?
      lasso.val.pred.lambda.1se[[l]] = c(lasso.val.pred.lambda.1se[[l]], predict(lasso.model.lambda.1se, newdata = x.test)) # predict on trained model
    } else {
      lasso.model.lambda.1se = null.model # if lasso sets all coeffs = 0, then use the null model
      lasso.val.pred.lambda.1se[[l]] = c(lasso.val.pred.lambda.1se[[l]], predict(lasso.model.lambda.1se, newdata = x.test)) # predict on trained model
      # cache <-  length(val.true[[l]])-length(lasso.val.pred.lambda.1se[[l]])
      # lasso.val.pred.lambda.1se[[l]] = c(lasso.val.pred.lambda.1se[[l]], rep(NA,cache)) # fill with NA(s) if invalid model was supplied
    }
    
    rf.fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(rf.variables.to.use,collapse=" + "))
    #check that the formula is valid (i.e. not empty)
    if(rf.fml!=paste0("cbind( ",top.names[l]," ) ~ ")){
      rf.model = randomForest(as.formula(rf.fml), data = x.train)  #weights = labs.wear$weight) # TODO: do we need to include weights?
      rf.val.pred[[l]] = c(rf.val.pred[[l]], predict(rf.model, newdata = x.test)) # predict on left out person
    } else {
      # rf.model = null.model # if lasso sets all coeffs = 0, then use the null model
      # rf.val.pred[[l]] = c(rf.val.pred[[l]], predict(rf.model, newdata = x.test)) # predict on left out person
    }
    
    ## pull out features from rf models ##
    rf.features.list <- as.matrix(importance(rf.model)[order(importance(rf.model), decreasing=TRUE),])
    
    
    tmp <- data.frame("test"=rep(top.names[l],length(rf.features.list)),
                      "cv.run"=rep(k,length(rf.features.list)),
                      "left.out.person"=rep(patients[k],length(rf.features.list)),
                      "rf.feature"=unlist(dimnames(rf.features.list)),
                      "rf.coef.value"=as.numeric(rf.features.list))
    rf.features <- rbind(rf.features,tmp)
    # t<- anova(bivar.null.lm.model, bivar.lm.model) # to get p-values for model
    # p.value[[l]] <- as.numeric(t[2,][["Pr(>F)"]])  # to get p-values for model
  }
}

## calculate correlation coefficients and pct var explained by the models (lambda manual)
rsq.lasso.lambda.manual = c()
num.cor.pairs.lasso.lambda.manual = c()
p.val.rsq.lasso.manual = c()
rssm.lasso.lambda.manual = c()
rss0.lasso.lambda.manual = c()
lasso.pct.var.explained.lambda.manual = c()
lasso.num.Records.lambda.manual <- c()

rsq.lasso.lambda.min = c()
num.cor.pairs.lasso.lambda.min = c()
p.val.rsq.lasso.min = c()
rssm.lasso.lambda.min = c()
rss0.lasso.lambda.min = c()
lasso.pct.var.explained.lambda.min = c()
lasso.num.Records.lambda.min <- c()

rsq.lasso.lambda.1se = c()
num.cor.pairs.lasso.lambda.1se = c()
p.val.rsq.lasso.1se = c()
rssm.lasso.lambda.1se = c()
rss0.lasso.lambda.1se = c()
lasso.pct.var.explained.lambda.1se = c()
lasso.num.Records.lambda.1se <- c()

rsq.rf = c()
num.cor.pairs.rf = c()
p.val.rsq.rf = c()
rssm.rf = c()
rss0.rf = c()
rf.pct.var.explained = c()
rf.num.Records <- c()

#note: rf only runs once below

for (j in 1:length(top.names)){
  #lasso (lambda.manual)
  if(length(which(!is.na(lasso.val.pred.lambda.manual[[j]])))>=3){
    num.cor.pairs.lasso.lambda.manual <- c(num.cor.pairs.lasso.lambda.manual, length(which(!is.na(lasso.val.pred.lambda.manual[[j]]))))
    #insert step here to check if sample size for correlation test meets minimum threshold
    rsq.lasso.lambda.manual = c(rsq.lasso.lambda.manual, cor(lasso.val.pred.lambda.manual[[j]], val.true[[j]], use = "complete.obs"))
    p.val.rsq.lasso.manual <- c(p.val.rsq.lasso.manual, cor.test(lasso.val.pred.lambda.manual[[j]], val.true[[j]], use = "complete.obs")$p.value)
    #insert step here to check if correlation was significant?
    rssm.lasso.lambda.manual = sum(na.omit((val.true[[j]] - lasso.val.pred.lambda.manual[[j]])^2))
    rss0.lasso.lambda.manual = sum(na.omit((val.true[[j]] - null.val.pred[[j]])^2))
    lasso.pct.var.explained.lambda.manual = c(lasso.pct.var.explained.lambda.manual, (1 - ( rssm.lasso.lambda.manual / rss0.lasso.lambda.manual )))
    lasso.num.Records.lambda.manual <- c(num.Records, length(lasso.val.pred.lambda.manual[[j]]))
  } else {
    p.val.rsq.lasso.manual <- c(p.val.rsq.lasso.manual, NA)
    num.cor.pairs.lasso.lambda.manual <- c(num.cor.pairs.lasso.lambda.manual, 0)
    rsq.lasso.lambda.manual = c(rsq.lasso.lambda.manual, NA)
    lasso.pct.var.explained.lambda.manual = c(lasso.pct.var.explained.lambda.manual, NA)
    lasso.num.Records.lambda.manual <- c(num.Records, NA)
  }
  #lasso (lambda.min)
  if(length(which(!is.na(lasso.val.pred.lambda.min[[j]])))>=3){
    num.cor.pairs.lasso.lambda.min <- c(num.cor.pairs.lasso.lambda.min, length(which(!is.na(lasso.val.pred.lambda.min[[j]]))))
    #insert step here to check if sample size for correlation test meets minimum threshold
    rsq.lasso.lambda.min = c(rsq.lasso.lambda.min, cor(lasso.val.pred.lambda.min[[j]], val.true[[j]], use = "complete.obs"))
    p.val.rsq.lasso.min <- c(p.val.rsq.lasso.min, cor.test(lasso.val.pred.lambda.min[[j]], val.true[[j]], use = "complete.obs")$p.value)
    #insert step here to check if correlation was significant?
    rssm.lasso.lambda.min = sum(na.omit((val.true[[j]] - lasso.val.pred.lambda.min[[j]])^2))
    rss0.lasso.lambda.min = sum(na.omit((val.true[[j]] - null.val.pred[[j]])^2))
    lasso.pct.var.explained.lambda.min = c(lasso.pct.var.explained.lambda.min, (1 - ( rssm.lasso.lambda.min / rss0.lasso.lambda.min )))
    lasso.num.Records.lambda.min <- c(num.Records, length(lasso.val.pred.lambda.min[[j]]))    
  } else {
    p.val.rsq.lasso.min <- c(p.val.rsq.lasso.min, NA)
    num.cor.pairs.lasso.lambda.min <- c(num.cor.pairs.lasso.lambda.min, 0)
    rsq.lasso.lambda.min = c(rsq.lasso.lambda.min, NA)
    lasso.pct.var.explained.lambda.min = c(lasso.pct.var.explained.lambda.min, NA)
    lasso.num.Records.lambda.min <- c(num.Records, NA)   
  }
  #lasso (lambda.1se)
  if(length(which(!is.na(lasso.val.pred.lambda.1se[[j]])))>=3){
    num.cor.pairs.lasso.lambda.1se <- c(num.cor.pairs.lasso.lambda.1se, length(which(!is.na(lasso.val.pred.lambda.min[[j]]))))
    #insert step here to check if sample size for correlation test meets minimum threshold
    rsq.lasso.lambda.1se = c(rsq.lasso.lambda.1se, cor(lasso.val.pred.lambda.1se[[j]], val.true[[j]], use = "complete.obs"))
    p.val.rsq.lasso.1se <- c(p.val.rsq.lasso.1se, cor.test(lasso.val.pred.lambda.1se[[j]], val.true[[j]], use = "complete.obs")$p.value)
    #insert step here to check if correlation was significant?
    rssm.lasso.lambda.1se = sum(na.omit((val.true[[j]] - lasso.val.pred.lambda.1se[[j]])^2))
    rss0.lasso.lambda.1se = sum(na.omit((val.true[[j]] - null.val.pred[[j]])^2))
    lasso.pct.var.explained.lambda.1se = c(lasso.pct.var.explained.lambda.1se, (1 - ( rssm.lasso.lambda.1se / rss0.lasso.lambda.1se )))
    lasso.num.Records.lambda.1se <- c(num.Records, length(lasso.val.pred.lambda.1se[[j]]))    
  } else {
    p.val.rsq.lasso.1se <- c(p.val.rsq.lasso.1se, NA)
    num.cor.pairs.lasso.lambda.1se <- c(num.cor.pairs.lasso.lambda.1se, 0)
    rsq.lasso.lambda.1se = c(rsq.lasso.lambda.1se, NA)
    lasso.pct.var.explained.lambda.1se = c(lasso.pct.var.explained.lambda.1se, NA)
    lasso.num.Records.lambda.1se <- c(num.Records, NA)   
  }
  #rf
  if(length(which(!is.na(rf.val.pred[[j]])))>=3){
    num.cor.pairs.rf <- c(num.cor.pairs.rf, length(which(!is.na(rf.val.pred[[j]]))))
    #insert step here to check if sample size for correlation test meets minimum threshold
    rsq.rf = c(rsq.rf, cor(rf.val.pred[[j]], val.true[[j]], use = "complete.obs"))
    p.val.rsq.rf <- c(p.val.rsq.rf, cor.test(rf.val.pred[[j]], val.true[[j]], use = "complete.obs")$p.value)
    #insert step here to check if correlation was significant?
    rssm.rf = sum(na.omit((val.true[[j]] - rf.val.pred[[j]])^2))
    rss0.rf = sum(na.omit((val.true[[j]] - null.val.pred[[j]])^2))
    rf.pct.var.explained = c(rf.pct.var.explained, (1 - ( rssm.rf / rss0.rf )))
    rf.num.Records <- c(num.Records, length(rf.val.pred[[j]]))
  } else {
    p.val.rsq.rf <- c(p.val.rsq.rf, NA)
    num.cor.pairs.rf <- c(num.cor.pairs.rf, 0)
    rsq.rf = c(rsq.rf, NA)
    rf.pct.var.explained = c(rf.pct.var.explained, NA)
    rf.num.Records <- c(num.Records, NA)
  }
}

names(rsq.lasso.lambda.manual) = top.names
names(lasso.pct.var.explained.lambda.manual) = top.names
lasso.sqrt.pct.var.lambda.manual <- sqrt(lasso.pct.var.explained.lambda.manual)
#^ Error about NaNs may occur from trying to sqrt a negative number

names(rsq.lasso.lambda.min) = top.names
names(lasso.pct.var.explained.lambda.min) = top.names
lasso.sqrt.pct.var.lambda.min <- sqrt(lasso.pct.var.explained.lambda.min)
#^ Error about NaNs may occur from trying to sqrt a negative number

names(rsq.lasso.lambda.1se) = top.names
names(lasso.pct.var.explained.lambda.1se) = top.names
lasso.sqrt.pct.var.lambda.1se <- sqrt(lasso.pct.var.explained.lambda.1se)
#^ Error about NaNs may occur from trying to sqrt a negative number

names(rsq.rf) = top.names
names(rf.pct.var.explained) = top.names
rf.sqrt.pct.var <- sqrt(rf.pct.var.explained)
#^ Error about NaNs may occur from trying to sqrt a negative number

fig.2c.df <- cbind(rownames(as.data.frame(sqrt.pct.var)), 
                   as.data.frame(sqrt.pct.var), 
                   as.data.frame(lasso.sqrt.pct.var.lambda.manual),
                   as.data.frame(lasso.sqrt.pct.var.lambda.min),
                   as.data.frame(lasso.sqrt.pct.var.lambda.1se),
                   as.data.frame(rf.sqrt.pct.var), 
                   as.data.frame(num.cor.pairs.lasso.lambda.manual),
                   as.data.frame(num.cor.pairs.lasso.lambda.min),
                   as.data.frame(num.cor.pairs.lasso.lambda.1se),
                   as.data.frame(num.cor.pairs.rf),
                   as.data.frame(p.val.rsq.lasso.manual),
                   as.data.frame(p.val.rsq.lasso.min),
                   as.data.frame(p.val.rsq.lasso.1se),
                   as.data.frame(p.val.rsq.rf),
                   row.names=NULL)


colnames(fig.2c.df)<-c("test", "vitals", "lasso.manual", "lasso.min", "lasso.1se", "rf", 
                       "num.obs.lasso.manual","num.obs.lasso.min","num.obs.lasso.1se","num.obs.rf",
                       "p.val.lasso.manual","p.val.lasso.min","p.val.lasso.1se","p.val.rf")
#fig.2c.df$test = factor(fig.2c.df$test, levels = as.factor(names(sqrt.pct.var)[order(-sqrt.pct.var)]))
fig.2c.corr.coefs <- cbind(rownames(as.data.frame(rsq.vitals)), 
                           as.data.frame(rsq.vitals), 
                           as.data.frame(rsq.lasso.lambda.manual), 
                           as.data.frame(rsq.lasso.lambda.min), 
                           as.data.frame(rsq.lasso.lambda.1se), 
                           as.data.frame(rsq.rf), 
                           row.names=NULL)
colnames(fig.2c.corr.coefs)<-c("test", "vitals", "lasso.manual", "lasso.min", "lasso.1se", "rf")

#fig.2c.corr.coefs$test = factor(fig.2c.corr.coefs$test, levels = as.factor(names(rsq.vitals)[order(-rsq.vitals)]))
# fig.2c.corr.coefs[fig.2c.corr.coefs<0]=0 # clamp to zero
# ^This line was throwing an error; revised version below:
fig.2c.corr.coefs[,c("vitals","lasso.manual","lasso.min","lasso.1se","rf")] <- sapply(fig.2c.corr.coefs[,c("vitals","lasso.manual","lasso.min","lasso.1se","rf")],function(x) ifelse(x<0,0,x)) # clamp to zero
#fig.2c.corr.coefs$test = factor(fig.2c.corr.coefs$test, levels = as.factor(fig.2c.corr.coefs$test[order(-fig.2c.corr.coefs$lasso.min)]))

#choose lambda to plot ("lasso.manual", "lasso.min", or "lasso.1se")

##UNCOMMENT IF RUNNING LOCALLY
# lambda.choice <- "lasso.min"
# 
# fig.2c.plot <- melt(fig.2c.corr.coefs,id.vars="test")
# fig.2c.plot[,3][is.na(fig.2c.plot[,3])] <- 0 #replace % var explained of NaN w/ 0
# fig.2c.plot$test = factor(fig.2c.plot$test, levels = as.factor(fig.2c.plot$test[order(-fig.2c.plot$value)]))
# #^ Ran out of time, but I can simplify this later, which will probably rid the error.
# fig.2c <- fig.2c.plot
# #fig.2c <- fig.2c.plot[order(-fig.2c.plot[,3]),] # reorder by LM Vitals
## DONE UNCOMMENT

num.Records <- as.data.frame(num.Records)
# num.Records.2 <- transform(num.Records, TrainingObs = as.numeric(TrainingObs),
#                          TestObs = as.numeric(TestObs))
# Plot the % var explained

##UNCOMMENT IF RUNNING LOCALLY
# ggplot(fig.2c[fig.2c$variable %in% c("vitals",lambda.choice,"rf"),], aes(x=test, y=value, color = variable)) + geom_point(size = 5, aes(shape=variable, color=variable)) +
#   weartals_theme +
#   ylim(0,1) +
#   scale_shape_discrete(breaks=c("vitals", lambda.choice, "rf"),
#                        labels=c("LM vitals", "LASSO", "RF")) +
#   scale_color_discrete(breaks=c("vitals", lambda.choice, "rf"),
#                        labels=c("LM vitals", "LASSO", "RF")) +
#   labs(x = "Lab tests",y = expression(paste("Sqrt of % Variance Explained")))
## DONE UNCOMMENT

## calculate correlation coefficients and pct var explained by the models (lambda min)

# remove coefficients associated with participants that had zero x.test data
num.Records <- data.frame(num.Records)
cache <- num.Records[num.Records$TestObs=="0",]
cache <- cache[,c(2,1)] #list of clin tests and iPOPs that had zero x.test data
names(cache) <- c("test","left.out.person")
cache$delete <- 1
tmp <- merge(lasso.features.lambda.manual,cache,all=TRUE)
tmp <- tmp[which(is.na(tmp$delete)),] #remove rows selected for deletion
lasso.features.lambda.manual <- tmp[,-which(names(tmp)=="delete")] #remove column called "delete"
tmp <- merge(lasso.features.lambda.min,cache,all=TRUE)
tmp <- tmp[which(is.na(tmp$delete)),] #remove rows selected for deletion
lasso.features.lambda.min <- tmp[,-which(names(tmp)=="delete")] #remove column called "delete"
tmp <- merge(lasso.features.lambda.1se,cache,all=TRUE)
tmp <- tmp[which(is.na(tmp$delete)),] #remove rows selected for deletion
lasso.features.lambda.1se <- tmp[,-which(names(tmp)=="delete")] #remove column called "delete"

# store the results
write.csv(fig.2c.df, "../SECURE_data/20180726/20180726_pct_var_WeekPrior_ThreeLambdas.csv",row.names=FALSE)
write.csv(fig.2c.corr.coefs, "../SECURE_data/20180726/20180726_corr_coefs_WeekPrior_ThreeLambdas.csv",row.names=FALSE)
write.table(num.Records, "../SECURE_data/20180726/20180726_WeekPrior_num_Records.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(num.Records.check, "../SECURE_data/20180726/20180726_WeekPrior_num_Records_check.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(lasso.features.lambda.manual, "../SECURE_data/20180726/20180726_WeekPrior_LassoFeaturesLambdaManual.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(lasso.features.lambda.1se, "../SECURE_data/20180726/20180726_WeekPrior_LassoFeaturesLambda1se.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(lasso.features.lambda.min, "../SECURE_data/20180726/20180726_WeekPrior_LassoFeaturesLambdaMin.csv",row.names=FALSE,col.names=FALSE, sep=",")
write.table(rf.features, "../SECURE_data/20180726/20180726_WeekPrior_RF_Features.csv",row.names=FALSE,col.names=FALSE, sep=",")
