
# Framework Paper Figures
# built from 20170905_thirtyk.R

#### OUTPUT: Figures for paper

#### LIBRARY DEPENDENCIES:
library(ggplot2)
library(data.table)
library(psych)
library(nlme)
library(MuMIn)
library(Rmisc)
library(gridExtra)
library(grid)
library(dplyr)
library(MASS)
library("ggthemes")
library(reshape2)
library(randomForest)
library("glmnet")

if(!dir.exists("plots")) dir.create("plots")

# FUNCTIONS
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

# Path to the directory with data
#dir = "../SECURE_data/"
dir = "/Users/jessilyn/Desktop/framework_paper/SECURE_data/"

###################
#### READ DATA ####
###################

#iPOP wearables/clinical combined data
# wear <- read.csv(paste0(dir, "Basis2016_Cleaned_NotNorm0824_WeekPrior.csv"),
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for Lukasz script
# do not use:  wear <- read.csv("/Users/jessilyn/Documents/Career_Development/Mentoring/RyanRunge/20170803_FINAL_LASSOS/Basis2016_Norm0824_WeekPrior.csv",
#                  header=TRUE,sep=',',stringsAsFactors=FALSE) # for other figures, may need to resurrect this one
timespans <-c("AllData",
              "MonthPrior",
              "2WeekPrior",
              "WeekPrior",
              "5DayPrior",
              "3DayPrior",
              "DayPrior" )

# wear <- read.csv(paste0("/srv/gsfs0/projects/snyder/jdunn/framework_paper/Basis_Timespan_Subset_Tables/", 
#                 "Basis2016_Clean_Norm_", timespans[1], "_20171020.csv"),
#                  header=TRUE,sep=',',stringsAsFactors=FALSE)
wear <- read.csv(paste0("/Users/jessilyn/Desktop/framework_paper/Figure2/20171103_Output_Tables_from_All_Lassos/bug_for_resting_definition/old_Basis_Timespan_Subset_Tables_for_Lassos/", "Basis2016_Clean_Norm_", timespans[7], "_20171020.csv"),
                 header=TRUE,sep=',',stringsAsFactors=FALSE)


# iPOP vitals (called vitals in Lukasz script)
#setwd("/srv/gsfs0/projects/snyder/jdunn/framework_paper/weartals")
setwd("/Users/jessilyn/Desktop/framework_paper/weartals")

iPOPvitals <- read.csv(paste0(dir, "vitals.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP Labs (called labs in Lukasz script)
iPOPlabs <- read.csv(
  paste0(dir, "lab_results_20170717.csv"),
  header=TRUE,sep=',',stringsAsFactors=FALSE)

# 30k vitals
vitals <- fread(paste0(dir, "all_vitals.csv"),
                header=TRUE,sep=',',stringsAsFactors=FALSE)
vitals <- data.frame(vitals)
# 30k labs
labs <- fread(paste0(dir, "all_labs.csv"),
              header=TRUE,sep=',',stringsAsFactors=FALSE)
# 30K labs/vitals combined file <- generated by 20170908_thirtyk.R
corDf <- read.csv(paste0(dir, "20170905_Cleaned_joined_30k_labs_vitals.csv"),
                   header=TRUE,sep=',',stringsAsFactors=FALSE)

#iPOP demographics
iPOPdemographics <- read.csv(paste0(dir, "SECURE_ClinWearDemo_SamplePop.csv"),
                  header=TRUE,sep=',',stringsAsFactors=FALSE)

###################
### CLEAN DATA ####
###################

### clean iPOP Vitals ###
names(iPOPvitals)[which(names(iPOPvitals)=="HIMCID")] <- "iPOP_ID"
names(iPOPvitals)[which(names(iPOPvitals)=="RECORDED_TIME")] <- "Clin_Result_Date"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Pulse.")] <- "Pulse"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Temp.")] <- "Temp"
names(iPOPvitals)[which(names(iPOPvitals)=="X.BP.")] <- "BP"
names(iPOPvitals)[which(names(iPOPvitals)=="X.Bmi.")] <- "BMI"

for (i in 1:length(iPOPvitals$BP)){
  iPOPvitals$systolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][1]
  iPOPvitals$diastolic[i] <- strsplit(as.character(iPOPvitals$BP),'/')[[i]][2]
}

#Reformat dates
iPOPvitals$Clin_Result_Date <- format(
  as.Date(iPOPvitals$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

#Make correlation variables numeric
iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")] <- apply(
  iPOPvitals[,c("Pulse","Temp","BP","BMI","systolic", "diastolic")], 2,
  function(x) as.numeric(as.character(x)))

#### CLEAN iPOP LABS DATA ####

#Rename columns
names(iPOPlabs)[which(names(iPOPlabs)=="HIMC_ID")] <- "iPOP_ID"
names(iPOPlabs)[which(names(iPOPlabs)=="RESULT_TIME")] <- "Clin_Result_Date"

#Reformat dates
iPOPlabs$Clin_Result_Date <- format(
  as.Date(iPOPlabs$Clin_Result_Date, "%d-%b-%Y"), "%Y-%m-%d")

allClin <- c("ALKP", "LYM", "HSCRP", "ALT", "NEUT", "TBIL", "IGM", "TGL", "MCV", "MCH", "CO2", "LYMAB", "NEUTAB", "UALB", "CHOL", "MONOAB", "ALB", "NA.", "HDL", "PLT", "AG", "HGB", "EOS", "CL", "BUN", "GLOB", "CA", "CHOLHDL", "HCT", "BASOAB", "A1C", "GLU", "LDLHDL", "TP", "EOSAB", "K", "NHDL", "RBC", "MONO", "AST", "MCHC", "RDW", "BASO", "LDL")

for(i in 1:length(allClin)){ #this removes non-numeric characters
  cache <- iPOPlabs[,c(allClin[i])]
  cache <- gsub("[^0-9.]","",cache) #this keeps decimals
  iPOPlabs[,c(allClin[i])] <- cache
}
#Make correlation variables numeric
iPOPlabs[,c(allClin)] <- apply(
  iPOPlabs[,c(allClin)], 2,
  function(x) as.numeric(as.character(x)))

#subset by allClin
iPOPlabs <- iPOPlabs[names(iPOPlabs) %in% c("iPOP_ID","Clin_Result_Date",allClin)]

#Merge data
iPOPcorDf <- merge(iPOPlabs,
                   iPOPvitals[,c("iPOP_ID","Clin_Result_Date",
                                 "Pulse","Temp","BMI","systolic","diastolic")],
                   by=c("iPOP_ID","Clin_Result_Date"))

### clean iPOPcorDf ###
iPOPcorDf[, -c(1,2)] <- apply(iPOPcorDf[, -c(1,2)], 2, remove_outliers)

### clean corDf ### 
corDf[, -c(1,2)] <- apply(corDf[, -c(1,2)], 2, remove_outliers) 

###############
#  Figure 2C  #
###############
## TODO: problem removing NAs for x.train and x.test for the multiple model runs (line 267)
# the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 

# old scripts: load-data.R - now embedded at the top of this script
# old scripts: population-30k.R - now embedded below in this script

# create ranked list of clinical laboratory tests by the correlation coefficients between observed and predicted values
# predicted values from simple bivariate models of (lab test ~ pulse + temp) using iPOP dataset
# LOO cross validation at the subject level 
patients = unique(iPOPcorDf$iPOP_ID)
nms = names(subset(iPOPcorDf, select=-c(iPOP_ID, Clin_Result_Date, Pulse, Temp, BMI, systolic, diastolic)))
corr.coefs.ipop.lm <- c() 
p.value <-0
ipop.lm <- c()
iPOPcorDf.demo <- merge(iPOPcorDf, iPOPdemographics[1:4], by="iPOP_ID")
# for (nm in nms){
#   print(nm)
#   for (i in 1:length(patients)){
#   print(patients[i])
#   train <- iPOPcorDf.demo[!iPOPcorDf.demo$iPOP_ID %in% patients[i],]
#   #train <- na.omit(cbind(subset(train, select = c(iPOP_ID, Pulse, Temp)), train[[nm]]))
#   train <- na.omit(cbind(subset(train, select = c(iPOP_ID, Pulse, Temp, AgeIn2016, Gender, Ethn)), train[[nm]])) # with demographics
#   colnames(train)[7] <- nm
#   test <- iPOPcorDf.demo[iPOPcorDf.demo$iPOP_ID %in% patients[i],]
#   #test <- na.omit(cbind(subset(test, select = c(iPOP_ID, Pulse, Temp)), test[[nm]])) 
#   test <- na.omit(cbind(subset(test, select = c(iPOP_ID, Pulse, Temp, AgeIn2016, Gender, Ethn)), test[[nm]])) # with demographics
#   colnames(test)[7] <- nm
#   if (length(test[[nm]])>0){
#   bivar.lm.model = lm(train[[nm]] ~ Pulse + Temp + AgeIn2016 + Gender + Ethn, data=train) # build the model
#   #bivar.lm.model = lm(train[[nm]] ~ Pulse + Temp, data=train) # build the model
#   lm.D0<-lm(train[[nm]] ~ 1)
#   t<- anova(lm.D0, bivar.lm.model)
#   p.value <- as.numeric(t[2,][["Pr(>F)"]])
#   bivar.lm.pred = predict(bivar.lm.model, newdata = test) # predict
#   bivar.lm.cor.coef <- cor(bivar.lm.pred, test[[nm]], use = "complete.obs")
#   ipop.lm= rbind(ipop.lm, c(nm,bivar.lm.cor.coef, p.value)) 
#   }
#   }
# }
# corr.coefs.ipop.lm <- ipop.lm
# corr.coefs.ipop.lm <- na.omit(as.data.frame(corr.coefs.ipop.lm)); corr.coefs.ipop.lm$V2 <- as.numeric(as.character(corr.coefs.ipop.lm$V2)); corr.coefs.ipop.lm$V3 <- as.numeric(as.character(corr.coefs.ipop.lm$V3))
# means<-aggregate(corr.coefs.ipop.lm[,2:3], by=list(corr.coefs.ipop.lm$V1), mean, na.action = na.omit)
# ci<-aggregate(corr.coefs.ipop.lm$V2, by=list(corr.coefs.ipop.lm$V1), function(x){mean(x)+c(-1.96,1.96)*sd(x)/sqrt(length(x))})
# means <- means [order(means[,2] ,decreasing = TRUE),]
# colnames(means)<- c("test", "corr.coef", "p.val")
# means = means[means$test %in% allClin,]
# write.table(means, "../SECURE_data/20180403_ranked_models_ipop_lm_with_demographics.csv",row.names=FALSE,col.names=FALSE, sep=",")

# Script to compare different models for predicting lab tests from iPOP wearables data (adapted from population-models.R)
source("ggplot-theme.R") # just to make things look nice

wear.variables <- unlist(read.table("FinalLasso_153WearableFactors.csv", stringsAsFactors = FALSE)) # the table of model features we want to work with
demo.variables <- c("AgeIn2016", "Gender", "Ethn")
wear$Gender <- as.factor(wear$Gender)
wear$Ethn <- as.factor(wear$Ethn)

# Get the vitals models

#ranked = read.csv("../SECURE_data/20180322_ranked_models_test_lm.csv",header = FALSE)
ranked = read.csv("../SECURE_data/20180403_ranked_models_ipop_lm_with_demographics.csv",header = FALSE)
top.names<-c("LYM", "NEUT", "LYMAB", "NEUTAB", "IGM", "HSCRP", "ALKP", "ALT", "HDL", "MCV", "TBIL", "CHOLHDL", "GLOB", "AG", "CO2", "CA", "LDLHDL", "BUN", "NHDL", "NA.", "UALB", "MONOAB", "CHOL", "MONO", "RDW", "HCT", "TP", "TGL", "EOS", "LDL", "GLU", "AST", "PLT", "K", "EOSAB", "BASOAB", "MCH", "ALB", "HGB", "A1C", "CL", "RBC", "BASO", "MCHC") # names of lab tests from the 30k simple bivariate models
top.names<-top.names[top.names %in% names(wear)] # only keep the lab names that are also present in the iPOP data
rsq.all = t(as.matrix(ranked$V2))
colnames(rsq.all) = ranked$V1[ranked$V1 %in% top.names] # Ordering same as corr.coefs <- will change this 

# LOO
patients = unique(wear$iPOP_ID)

modes = c("all","lasso")
model.names = c("lm","rf")
num.Records = list(left.Out=list(),lab.Test=list(), num.Train.Obs=list(), num.Test.Obs=list()) # make sure sufficient number of observations for each test and training set
idx=1 # index for entry into num.Records
# p.val.lm <- as.data.frame()

#top.names <- top.names[1:3] # for troubleshooting

for (mode in modes){
  # Build two lists: predicted vs true
  val.true = list()
  val.pred = list(lm=list(),rf=list())
  cat("Feature selection:",mode,"\n")
  
  # Build models using wearables data
  for (k in 1:length(patients)){
  #for (k in 1:2){
    train <- patients[patients != patients[k]]
    test <- patients[patients == patients[k]]
    ######################
    ## Build random forest and linear models
    # We will predict one by one, let's create a vector of tests
    res.true <- list()
    res.pred = list(lm=list(),rf=list())
    p.value<-list()
    cat("Patient",patients[k],"\n") # LOO
    

    for (l in 1:length(top.names)){
      print(l)
      cat("Test",top.names[l],"\n")
      x.train<-wear[ wear$iPOP_ID %in% train, ] # subset input data by training set
      x.train<-x.train[,colnames(x.train) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
      x.train<- na.omit(x.train) # skip nas and nans ## TODO: the way this script is written, you will lose a lot of data because you take the number of lab visits down to the test with the minimum number of visits. However, if you do na.omit after the next line, you have to change your matrix to accept dynamic number of row entries. Not sure how to do this yet, so for now just reducing the data amount by a lot. 
      predictors <- as.data.frame(x.train[,colnames(x.train) %in% c(wear.variables, demo.variables)]) # later add in demographics
      
      outcome <- as.matrix(x.train[,colnames(x.train) %in% top.names[l]]) # matrix of outcome for model building # tried adding as.numeric after as.matrix() but that introduced new issues
      
      # create test set
      x.test<-wear[ wear$iPOP_ID %in% test, ] # subset input data by testing set
      x.test<-x.test[,colnames(x.test) %in% c(top.names[l], wear.variables, demo.variables)] # subset input data by lab: only take current lab test of interest
      x.test<- na.omit(x.test) # skip nas and nans ## TODO: SEE ABOVE na.omit FOR ISSUE WITH THIS
      res.true[[l]] = as.matrix(x.test[,top.names[l]]) # true values of left out person

      if (!nrow(x.test)){ # if there are no true values for the left out person, record as NAs
        res.true[[l]] = NA # TODO: keep track of number of people this happens to
      }
      if(mode == "all"){
        num.Records[[1]][[idx]] <- patients[k]
        num.Records[[2]][[idx]] <- top.names[l]
        num.Records[[3]][[idx]] <-length(outcome) ## store num training obs
        num.Records[[4]][[idx]] <- length(res.true[[l]]) ## store num test obs
        idx=idx+1 # to index entry into num.Records
        variables.to.use = c(wear.variables, demo.variables) # add in demographics
      }
      if(mode == "lasso"){
        # lasso 
        n <- as.numeric(length(outcome)) #optional argument for leave-one-out CV method for nfold

        dem = c("Gender", "Ethn") # do not use demographics for lasso
        glm.res = cv.glmnet(x=as.matrix(predictors[,-which(names(predictors) %in% dem)]),y=outcome,
                            standardize.response=FALSE,
                            family="gaussian",
			                      nfolds=n,
                            nlambda=100)
        variables.to.use = rownames(glm.res$glmnet.fit$beta[abs(glm.res$glmnet.fit$beta[,25]) > 1e-10,]) # TODO: this is an arbitrary rule for now
        variables.to.use = c(dem,variables.to.use) # add back Gender and ethn
      }
      
      # Random forest
      fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~",paste(variables.to.use,collapse=" + "))
      set.seed(1)
      models.wear.rf = randomForest(as.formula(fml),
                                    data = x.train)
                                    #weights = labs.wear$weight) # TODO: do we need to include this line?
      res.pred[["rf"]][[l]] = predict(models.wear.rf, newdata = x.test) # predict on left out person
      
      # LM  - always throws warnings; not sure why
      models.wear.lm = lm(as.formula(fml),
                          data = x.train)
                          # , weights = labs.wear$weight) # TODO: do we need to include this line?
      res.pred[["lm"]][[l]] = predict(models.wear.lm, newdata = x.test)
      # create a null model for significance testing
      fml = paste("cbind(",paste(top.names[l],collapse=" , "),") ~ 1")
      lm.D0<-lm(as.formula(fml), data=x.train) 
      t<- anova(lm.D0, models.wear.lm)
      # p.value[["lm"]][[l]] <- as.numeric(t[2,][["Pr(>F)"]])
      # if (mdl.name %in% "lm"){
      # print(p.value[["lm"]][[l]])
      # p.val.lm[k, l] <- as.numeric(t[2,][["Pr(>F)"]])}
      # if (!nrow(res.pred[["lm"]][[l]])){ # clarify w/ lukasz --> if there are no predictions from error in lm or rf, record pred values as NA
      #   res.pred[["lm"]][[l]] = NA
      #   res.pred[["rf"]][[l]] = NA
      # }
      # Add predictions and true values for the patient k

      for (mdl.name in model.names){
        if (l <= length(val.pred[[mdl.name]])) # TODO: I don't understand what the if else statements below are doing
          val.pred[[mdl.name]][[l]] = append(val.pred[[mdl.name]][[l]], res.pred[[mdl.name]][[l]]) #append new predictions to val.pred matrix
        else
          val.pred[[mdl.name]][[l]] = res.pred[[mdl.name]][[l]] # initiate val.pred matrix
      }

      if (l <= length(val.true))
        val.true[[l]] = append(val.true[[l]], res.true[[l]]) 
       else 
        val.true[[l]] = res.true[[l]] # initiate val.true matrix
    }

  }

  # Get correlation coeffs for each model
  for (mdl.name in model.names){
    rsq.wear = c()
    for (j in 1:length(top.names))
      rsq.wear = c(rsq.wear, cor(val.pred[[mdl.name]][[j]], na.omit(val.true[[j]])))
    names(rsq.wear) = top.names
    rsq.all = rbind(rsq.all, rsq.wear)
    rownames(rsq.all)[nrow(rsq.all)] = paste(mode,mdl.name,sep="-")
    
  }
}

num.Records <- do.call("cbind",num.Records) 
write.table(num.Records, "../SECURE_data/20180411/20180411_num_Records_AllData_demog.csv",row.names=FALSE,col.names=FALSE, sep=",")

rownames(rsq.all)[1] = "vitals"
  df = data.frame(rsq.all)
#df[df<0] = 0 # clamp correlations to 0
df$name = rownames(rsq.all)
#df <- df [order(df[,*make this the RF_all or LM_LASSO*] ,decreasing = TRUE),]


# Plot the correlations
data = melt(df, id = "name")
colnames(data) = c("model","test","r_squared")
write.table(data, "../SECURE_data/20180411/20180411_corr_coeffs_AllData_demog.csv",row.names=FALSE,col.names=FALSE, sep=",")

#png('SECURE_data/figure2C.png',width = 1700, height = 600,res=120)
# vitals_res = data[data$model == "vitals",]
# data$test = factor(data$test, levels = vitals_res$test[order(-vitals_res$r_squared)])
# ggplot(data, aes(test,r_squared, color = model)) + geom_point(size = 5, aes(shape=model, color=model)) +
#   weartals_theme + 
#   ylim(0,0.5) +
#   scale_shape_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
#                        labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
#   scale_color_discrete(breaks=c("all-rf", "lasso-rf", "all-lm", "lasso-lm", "vitals"),
#                        labels=c("RF all variables", "RF + LASSO", "LM all variables", "LM + LASSO", "LM vitals")) +
#   labs(x = "Lab tests",y = expression(paste("correlation"))) + ggtitle("Model comparison")
#dev.off()